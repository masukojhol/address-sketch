<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Sketch">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#4a90d9">

    <title>Address Sketch - Auto Route Generator</title>
    <meta name="description" content="Generate simple address sketches from any location. Enter FROM and TO, get an easy-to-draw route map with landmarks.">

    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/svg+xml" href="icons/icon.svg">

    <!-- Google Maps API -->
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAcYZaAgnCQCJx4y848ezC32_7PYTkjWBM&libraries=places"></script>

    <!-- Google AdSense -->
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1157507558678597" crossorigin="anonymous"></script>

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        html, body { overflow-x: hidden; overscroll-behavior: none; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f0f2f5;
            min-height: 100vh;
        }

        .header {
            background: linear-gradient(135deg, #4a90d9, #357abd);
            color: white;
            padding: 12px 16px;
            padding-top: max(12px, env(safe-area-inset-top));
            text-align: center;
        }
        .header h1 { font-size: 18px; font-weight: 600; }
        .header p { font-size: 12px; opacity: 0.9; margin-top: 4px; }

        .main-container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 12px;
        }


        /* Route Generator */
        .route-panel {
            background: #fff;
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            margin-bottom: 12px;
        }
        .input-group {
            margin-bottom: 12px;
        }
        .input-group label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: #666;
            margin-bottom: 6px;
        }
        .input-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 15px;
            outline: none;
            transition: border-color 0.2s;
        }
        .input-group input:focus { border-color: #4a90d9; }
        .input-hint {
            font-size: 11px;
            color: #999;
            margin-top: 4px;
        }
        .input-with-btn {
            display: flex;
            gap: 8px;
        }
        .input-with-btn input {
            flex: 1;
        }
        .location-btn {
            padding: 12px 14px;
            background: #27ae60;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            white-space: nowrap;
            transition: all 0.2s;
        }
        .location-btn:active { transform: scale(0.95); }
        .location-btn:disabled { opacity: 0.6; cursor: not-allowed; }

        .generate-btn {
            width: 100%;
            padding: 14px;
            background: linear-gradient(135deg, #4a90d9, #357abd);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, opacity 0.2s;
        }
        .generate-btn:active { transform: scale(0.98); }
        .generate-btn:disabled { opacity: 0.6; cursor: not-allowed; }

        .status-msg {
            text-align: center;
            padding: 12px;
            font-size: 14px;
            color: #666;
        }
        .status-msg.error { color: #e74c3c; }

        /* Map Preview */
        .map-container {
            background: #fff;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            margin-bottom: 12px;
        }
        #map {
            height: 250px;
            width: 100%;
        }

        /* Route Display */
        .route-display {
            background: #fff;
            border-radius: 16px;
            padding: 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        }
        .route-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding: 0 8px;
        }
        .route-header h3 {
            font-size: 18px;
            color: #333;
            font-weight: 600;
        }
        .route-distance {
            font-size: 16px;
            color: #22c55e;
            font-weight: 600;
        }
        .route-map-wrapper {
            position: relative;
            border-radius: 12px;
            overflow: hidden;
            height: 450px;
        }
        #satelliteRouteMap {
            width: 100%;
            height: 100%;
        }
        .btn-primary { background: linear-gradient(135deg, #4a90d9, #357abd); color: #fff; }
        .btn-secondary { background: #e0e0e0; color: #333; }
        .btn-danger { background: #e74c3c; color: white; }
        .turn-instructions {
            margin-top: 16px;
            background: #f8f9fa;
            border-radius: 12px;
            padding: 16px;
            max-height: 300px;
            overflow-y: auto;
        }
        .turn-header {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid #e0e0e0;
        }
        .turn-step {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 10px;
            margin-bottom: 8px;
            background: #fff;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid #e0e0e0;
        }
        .turn-step:hover {
            background: #e8f4fd;
            border-color: #4a90d9;
        }
        .turn-step.active {
            background: #dbeafe;
            border-color: #4a90d9;
        }
        .step-number {
            width: 28px;
            height: 28px;
            background: #4a90d9;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 600;
            flex-shrink: 0;
        }
        .step-content {
            flex: 1;
        }
        .step-instruction {
            font-size: 13px;
            color: #333;
            line-height: 1.4;
        }
        .step-distance {
            font-size: 11px;
            color: #666;
            margin-top: 4px;
        }
        .step-icon {
            font-size: 20px;
            flex-shrink: 0;
        }
        .key-points-title {
            font-size: 14px;
            font-weight: 600;
            color: #4a90d9;
            margin-bottom: 12px;
            padding: 8px 12px;
            background: #e8f4fd;
            border-radius: 8px;
            text-align: center;
        }


        /* Ads */
        .ad-container {
            background: #e0e0e0;
            border-radius: 8px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #999;
            font-size: 11px;
            margin-bottom: 12px;
        }

        .footer {
            text-align: center;
            padding: 15px;
            color: #888;
            font-size: 11px;
        }

        /* Loading */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .spinner {
            width: 20px;
            height: 20px;
            border: 3px solid #e0e0e0;
            border-top-color: #4a90d9;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        @media (max-width: 600px) {
            .header h1 { font-size: 16px; }
        }

        @media print {
            .header, .route-panel, .map-container, .ad-container, .footer { display: none !important; }
        }
    </style>
</head>
<body>
    <header class="header">
        <h1>Address Sketch Tool</h1>
        <p>Generate route sketches for bank forms</p>
    </header>

    <div class="main-container">
        <!-- Top Ad -->
        <div class="ad-container">
            <ins class="adsbygoogle" style="display:block" data-ad-format="auto"
                data-full-width-responsive="true" data-ad-client="ca-pub-1157507558678597"
                data-ad-slot="XXXXXXXXXX"></ins>
        </div>

        <!-- Route Generator -->
            <div class="route-panel">
                <div class="input-group">
                    <label>üìç FROM (Your Current Location)</label>
                    <div class="input-with-btn">
                        <input type="text" id="fromLocation" placeholder="Click 'Use My Location' or select on map">
                        <button class="location-btn" id="getLocationBtn" onclick="getCurrentLocation()">üìç My Location</button>
                        <button class="location-btn" style="background:#3498db;" onclick="openMapPicker('from')">üó∫Ô∏è Map</button>
                    </div>
                    <div class="input-hint" id="locationHint">Auto-detecting your location...</div>
                </div>
                <div class="input-group">
                    <label>üè† TO (Your Destination)</label>
                    <div class="input-with-btn">
                        <input type="text" id="toLocation" placeholder="Enter address or select on map">
                        <button class="location-btn" style="background:#3498db;" onclick="openMapPicker('to')">üó∫Ô∏è Select on Map</button>
                    </div>
                    <div class="input-hint" id="toHint">Enter address or pick location on map</div>
                </div>
                <button class="generate-btn" id="generateBtn" onclick="generateRoute()">
                    Generate Route Sketch
                </button>
                <div class="status-msg" id="statusMsg"></div>
            </div>

            <!-- Map Preview -->
            <div class="map-container" id="mapContainer" style="display:none;">
                <div id="map"></div>
            </div>

            <!-- Route Display with Satellite -->
            <div class="route-display" id="routeDisplay" style="display:none;">
                <div class="route-header">
                    <h3 id="routeTitle">Your Route</h3>
                    <span class="route-distance" id="routeDistanceLabel"></span>
                </div>
                <div class="route-map-wrapper" id="routeMapWrapper">
                    <div id="satelliteRouteMap"></div>
                </div>
                <div class="turn-instructions" id="turnInstructions">
                    <div class="turn-header">Turn-by-Turn Directions</div>
                    <div id="turnStepsList"></div>
                </div>
            </div>

        <!-- Bottom Ad -->
        <div class="ad-container">
            <ins class="adsbygoogle" style="display:block" data-ad-format="auto"
                data-full-width-responsive="true" data-ad-client="ca-pub-1157507558678597"
                data-ad-slot="XXXXXXXXXX"></ins>
        </div>
    </div>

    <footer class="footer">
        Address Sketch Tool - Generate route maps for bank forms & documents
    </footer>

    <!-- Map Picker Modal -->
    <div id="mapPickerModal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.8);z-index:200;">
        <div style="height:100%;display:flex;flex-direction:column;">
            <div style="background:#4a90d9;color:white;padding:15px;display:flex;justify-content:space-between;align-items:center;">
                <h3 style="font-size:16px;" id="mapPickerTitle">Select Location on Map</h3>
                <button onclick="closeMapPicker()" style="background:none;border:none;color:white;font-size:24px;cursor:pointer;">√ó</button>
            </div>
            <div style="padding:10px;background:#fff;">
                <input type="text" id="mapSearchInput" placeholder="Search location..." style="width:100%;padding:12px;border:2px solid #e0e0e0;border-radius:8px;font-size:15px;">
            </div>
            <div id="pickerMap" style="flex:1;"></div>
            <div style="background:#fff;padding:15px;">
                <div id="selectedLocationText" style="font-size:13px;color:#666;margin-bottom:10px;min-height:20px;">Tap on map to select location</div>
                <div style="display:flex;gap:10px;">
                    <button onclick="closeMapPicker()" style="flex:1;padding:12px;border:none;background:#e0e0e0;border-radius:8px;cursor:pointer;font-size:14px;">Cancel</button>
                    <button onclick="confirmMapSelection()" id="confirmMapBtn" style="flex:1;padding:12px;border:none;background:#27ae60;color:white;border-radius:8px;cursor:pointer;font-size:14px;" disabled>Confirm Location</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ==================== AUTO ROUTE GENERATOR ====================
        let map = null;
        let routeData = null;
        let landmarks = [];
        let currentLocationCoords = null;
        let directionsService = null;
        let directionsRenderer = null;

        // Map Picker variables
        let pickerMap = null;
        let pickerMarker = null;
        let pickerTarget = null; // 'from' or 'to'
        let selectedPickerCoords = null;
        let selectedPickerAddress = null;
        let placesAutocomplete = null;

        // Get current location on page load
        window.addEventListener('load', () => {
            getCurrentLocation();
        });

        // ==================== MAP PICKER (Google Maps) ====================
        function openMapPicker(target) {
            pickerTarget = target;
            selectedPickerCoords = null;
            selectedPickerAddress = null;

            const modal = document.getElementById('mapPickerModal');
            const title = document.getElementById('mapPickerTitle');
            const confirmBtn = document.getElementById('confirmMapBtn');
            const selectedText = document.getElementById('selectedLocationText');

            title.textContent = target === 'from' ? 'Select FROM Location' : 'Select TO Location';
            selectedText.textContent = 'Tap on map to select location';
            confirmBtn.disabled = true;
            modal.style.display = 'block';

            // Initialize or reset picker map
            setTimeout(() => {
                if (!pickerMap) {
                    const mapOptions = {
                        center: { lat: 20.5937, lng: 78.9629 }, // India center
                        zoom: 5,
                        mapTypeControl: true,
                        mapTypeControlOptions: {
                            style: google.maps.MapTypeControlStyle.HORIZONTAL_BAR,
                            position: google.maps.ControlPosition.TOP_LEFT,
                            mapTypeIds: ['roadmap', 'satellite', 'hybrid', 'terrain']
                        },
                        streetViewControl: false,
                        fullscreenControl: false
                    };
                    pickerMap = new google.maps.Map(document.getElementById('pickerMap'), mapOptions);

                    // Click to select location
                    pickerMap.addListener('click', (e) => {
                        selectLocationOnMap(e.latLng.lat(), e.latLng.lng());
                    });

                    // Setup Places Autocomplete
                    const searchInput = document.getElementById('mapSearchInput');
                    placesAutocomplete = new google.maps.places.Autocomplete(searchInput, {
                        fields: ['geometry', 'formatted_address', 'name']
                    });
                    placesAutocomplete.addListener('place_changed', () => {
                        const place = placesAutocomplete.getPlace();
                        if (place.geometry) {
                            const lat = place.geometry.location.lat();
                            const lng = place.geometry.location.lng();
                            pickerMap.setCenter({ lat, lng });
                            pickerMap.setZoom(16);
                            selectLocationOnMap(lat, lng, place.formatted_address || place.name);
                        }
                    });
                }

                // If we have current location, center there
                if (currentLocationCoords && target === 'from') {
                    pickerMap.setCenter({ lat: currentLocationCoords.lat, lng: currentLocationCoords.lng });
                    pickerMap.setZoom(15);
                } else if (currentLocationCoords) {
                    pickerMap.setCenter({ lat: currentLocationCoords.lat, lng: currentLocationCoords.lng });
                    pickerMap.setZoom(13);
                }

                // Remove existing marker
                if (pickerMarker) {
                    pickerMarker.setMap(null);
                    pickerMarker = null;
                }

                // Clear search input
                document.getElementById('mapSearchInput').value = '';
            }, 100);
        }

        async function selectLocationOnMap(lat, lng, address = null) {
            selectedPickerCoords = { lat, lng };

            // Update marker
            if (pickerMarker) {
                pickerMarker.setMap(null);
            }
            pickerMarker = new google.maps.Marker({
                position: { lat, lng },
                map: pickerMap,
                animation: google.maps.Animation.DROP
            });

            // Reverse geocode
            const selectedText = document.getElementById('selectedLocationText');
            const confirmBtn = document.getElementById('confirmMapBtn');

            if (address) {
                selectedPickerAddress = address;
                selectedText.textContent = address;
                confirmBtn.disabled = false;
                return;
            }

            selectedText.textContent = 'Getting address...';

            const geocoder = new google.maps.Geocoder();
            geocoder.geocode({ location: { lat, lng } }, (results, status) => {
                if (status === 'OK' && results[0]) {
                    selectedPickerAddress = results[0].formatted_address;
                    selectedText.textContent = selectedPickerAddress;
                } else {
                    selectedPickerAddress = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
                    selectedText.textContent = selectedPickerAddress;
                }
                confirmBtn.disabled = false;
            });
        }

        function confirmMapSelection() {
            if (!selectedPickerCoords || !selectedPickerAddress) return;

            if (pickerTarget === 'from') {
                document.getElementById('fromLocation').value = selectedPickerAddress;
                document.getElementById('locationHint').textContent = '‚úì Location selected from map';
                document.getElementById('locationHint').style.color = '#27ae60';
                currentLocationCoords = selectedPickerCoords;
                closeMapPicker();
                // Auto-focus TO input after FROM is selected
                setTimeout(() => document.getElementById('toLocation').focus(), 100);
            } else {
                document.getElementById('toLocation').value = selectedPickerAddress;
                document.getElementById('toHint').textContent = '‚úì Location selected from map';
                document.getElementById('toHint').style.color = '#27ae60';
                closeMapPicker();
            }
        }

        function closeMapPicker() {
            document.getElementById('mapPickerModal').style.display = 'none';
        }

        async function getCurrentLocation() {
            const btn = document.getElementById('getLocationBtn');
            const input = document.getElementById('fromLocation');
            const hint = document.getElementById('locationHint');

            if (!navigator.geolocation) {
                hint.textContent = 'Geolocation not supported. Enter address manually.';
                hint.style.color = '#e74c3c';
                return;
            }

            btn.disabled = true;
            btn.textContent = 'üìç Locating...';
            hint.textContent = 'Getting your location...';

            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;
                    currentLocationCoords = { lat, lng };

                    // Reverse geocode using Google
                    const geocoder = new google.maps.Geocoder();
                    geocoder.geocode({ location: { lat, lng } }, (results, status) => {
                        if (status === 'OK' && results[0]) {
                            input.value = results[0].formatted_address;
                            hint.textContent = '‚úì Location detected! You can edit if needed.';
                            hint.style.color = '#27ae60';
                        } else {
                            input.value = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
                            hint.textContent = '‚úì Coordinates detected';
                            hint.style.color = '#27ae60';
                        }
                        btn.disabled = false;
                        btn.textContent = 'üìç My Location';

                        // Auto-focus TO input after FROM is set
                        document.getElementById('toLocation').focus();
                    });
                },
                (error) => {
                    btn.disabled = false;
                    btn.textContent = 'üìç Try Again';
                    hint.style.color = '#e74c3c';

                    switch (error.code) {
                        case error.PERMISSION_DENIED:
                            hint.textContent = 'Location access denied. Enter address manually.';
                            break;
                        case error.POSITION_UNAVAILABLE:
                            hint.textContent = 'Location unavailable. Enter address manually.';
                            break;
                        case error.TIMEOUT:
                            hint.textContent = 'Location timeout. Try again or enter manually.';
                            break;
                        default:
                            hint.textContent = 'Could not get location. Enter address manually.';
                    }
                },
                { enableHighAccuracy: true, timeout: 10000, maximumAge: 60000 }
            );
        }

        async function generateRoute() {
            const from = document.getElementById('fromLocation').value.trim();
            const to = document.getElementById('toLocation').value.trim();
            const statusMsg = document.getElementById('statusMsg');
            const generateBtn = document.getElementById('generateBtn');

            if (!from || !to) {
                statusMsg.textContent = 'Please enter both FROM and TO locations';
                statusMsg.className = 'status-msg error';
                return;
            }

            generateBtn.disabled = true;
            generateBtn.innerHTML = '<span class="loading"><span class="spinner"></span> Generating...</span>';
            statusMsg.textContent = '';

            try {
                // Step 1: Geocode both locations
                statusMsg.textContent = 'Finding locations...';
                const [fromCoords, toCoords] = await Promise.all([
                    geocode(from),
                    geocode(to)
                ]);

                if (!fromCoords || !toCoords) {
                    throw new Error('Could not find one or both locations. Try more specific addresses.');
                }

                // Step 2: Get route
                statusMsg.textContent = 'Calculating route...';
                const route = await getRoute(fromCoords, toCoords);

                if (!route) {
                    throw new Error('Could not find a route between these locations.');
                }

                // Step 3: Get landmarks and rivers along route
                statusMsg.textContent = 'Finding landmarks and rivers...';
                const poiData = await getLandmarks(route.bbox, route.coordinates);
                landmarks = poiData.landmarks;
                const rivers = poiData.rivers;

                // Step 4: Show map
                showMap(fromCoords, toCoords, route);

                // Step 5: Generate simplified sketch
                statusMsg.textContent = 'Drawing sketch...';
                await generateSketch(fromCoords, toCoords, route, landmarks, rivers, from, to);

                statusMsg.textContent = 'Route generated! Scroll down to see the sketch.';
                statusMsg.className = 'status-msg';

            } catch (error) {
                statusMsg.textContent = error.message;
                statusMsg.className = 'status-msg error';
            } finally {
                generateBtn.disabled = false;
                generateBtn.innerHTML = 'Generate Route Sketch';
            }
        }

        async function geocode(address) {
            return new Promise((resolve) => {
                const geocoder = new google.maps.Geocoder();
                geocoder.geocode({ address: address }, (results, status) => {
                    if (status === 'OK' && results[0]) {
                        resolve({
                            lat: results[0].geometry.location.lat(),
                            lng: results[0].geometry.location.lng(),
                            name: results[0].formatted_address
                        });
                    } else {
                        resolve(null);
                    }
                });
            });
        }

        async function getRoute(from, to) {
            return new Promise((resolve) => {
                if (!directionsService) {
                    directionsService = new google.maps.DirectionsService();
                }

                directionsService.route({
                    origin: { lat: from.lat, lng: from.lng },
                    destination: { lat: to.lat, lng: to.lng },
                    travelMode: google.maps.TravelMode.DRIVING,
                    provideRouteAlternatives: true // Enable alternative routes
                }, (result, status) => {
                    if (status === 'OK' && result.routes && result.routes.length > 0) {
                        const route = result.routes[0];
                        const leg = route.legs[0];
                        const path = route.overview_path;

                        // Extract coordinates
                        const coords = path.map(p => ({ lat: p.lat(), lng: p.lng() }));

                        // Calculate bounding box
                        let minLat = Infinity, maxLat = -Infinity;
                        let minLng = Infinity, maxLng = -Infinity;

                        coords.forEach(c => {
                            minLng = Math.min(minLng, c.lng);
                            maxLng = Math.max(maxLng, c.lng);
                            minLat = Math.min(minLat, c.lat);
                            maxLat = Math.max(maxLat, c.lat);
                        });

                        resolve({
                            coordinates: coords,
                            steps: leg.steps,
                            distance: leg.distance.value,
                            duration: leg.duration.value,
                            bbox: { minLat, maxLat, minLng, maxLng },
                            googleRoute: result
                        });
                    } else {
                        resolve(null);
                    }
                });
            });
        }

        async function getLandmarks(bbox, routeCoords) {
            // Larger padding for better landmark coverage
            const padding = 0.01;
            const b = {
                minLat: bbox.minLat - padding,
                maxLat: bbox.maxLat + padding,
                minLng: bbox.minLng - padding,
                maxLng: bbox.maxLng + padding
            };

            const query = `
                [out:json][timeout:30];
                (
                    // Landmarks
                    node["amenity"~"hospital|bank|fuel|school|place_of_worship|police|bus_station|marketplace"](${b.minLat},${b.minLng},${b.maxLat},${b.maxLng});
                    node["shop"~"supermarket|mall|department_store"](${b.minLat},${b.minLng},${b.maxLat},${b.maxLng});
                    node["railway"="station"](${b.minLat},${b.minLng},${b.maxLat},${b.maxLng});
                    node["highway"~"traffic_signals|bus_stop"](${b.minLat},${b.minLng},${b.maxLat},${b.maxLng});
                    node["tourism"~"hotel|viewpoint"](${b.minLat},${b.minLng},${b.maxLat},${b.maxLng});
                    node["natural"="peak"](${b.minLat},${b.minLng},${b.maxLat},${b.maxLng});
                    // Rivers and water
                    way["waterway"~"river|stream"](${b.minLat},${b.minLng},${b.maxLat},${b.maxLng});
                    way["natural"="water"](${b.minLat},${b.minLng},${b.maxLat},${b.maxLng});
                );
                out body geom 50;
            `;

            try {
                const response = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    body: query
                });
                const data = await response.json();

                const landmarks = [];
                const rivers = [];

                data.elements.forEach(el => {
                    if (el.type === 'way' && (el.tags.waterway || el.tags.natural === 'water')) {
                        // It's a river/water body
                        if (el.geometry) {
                            rivers.push({
                                type: 'river',
                                name: el.tags.name || '',
                                coords: el.geometry.map(g => ({ lat: g.lat, lng: g.lon }))
                            });
                        }
                    } else if (el.type === 'node') {
                        // It's a landmark
                        landmarks.push({
                            lat: el.lat,
                            lng: el.lon,
                            type: el.tags.amenity || el.tags.shop || el.tags.railway || el.tags.highway || el.tags.tourism || el.tags.natural,
                            name: el.tags.name || ''
                        });
                    }
                });

                // Filter landmarks to those near the route
                const nearbyLandmarks = landmarks.filter(lm => {
                    return isNearRoute(lm, routeCoords, 0.008); // ~800m from route
                }).slice(0, 15);

                return { landmarks: nearbyLandmarks, rivers };
            } catch (e) {
                console.error('Landmark fetch error:', e);
                return { landmarks: [], rivers: [] };
            }
        }

        function isNearRoute(point, routeCoords, threshold) {
            for (let i = 0; i < routeCoords.length; i++) {
                const dist = Math.sqrt(
                    Math.pow(point.lat - routeCoords[i].lat, 2) +
                    Math.pow(point.lng - routeCoords[i].lng, 2)
                );
                if (dist < threshold) return true;
            }
            return false;
        }

        function showMap(from, to, route) {
            const mapContainer = document.getElementById('mapContainer');
            mapContainer.style.display = 'block';

            if (!map) {
                map = new google.maps.Map(document.getElementById('map'), {
                    center: { lat: from.lat, lng: from.lng },
                    zoom: 12,
                    mapTypeControl: true,
                    mapTypeControlOptions: {
                        style: google.maps.MapTypeControlStyle.HORIZONTAL_BAR,
                        position: google.maps.ControlPosition.TOP_RIGHT,
                        mapTypeIds: ['roadmap', 'satellite', 'hybrid', 'terrain']
                    },
                    streetViewControl: false
                });
                directionsRenderer = new google.maps.DirectionsRenderer({
                    suppressMarkers: false,
                    polylineOptions: {
                        strokeColor: '#4a90d9',
                        strokeWeight: 5
                    }
                });
                directionsRenderer.setMap(map);
            }

            // Display route using Google Directions
            if (route.googleRoute) {
                directionsRenderer.setDirections(route.googleRoute);
            }
        }

        // ==================== ROUTE DISPLAY ====================
        let satelliteRouteMap = null;
        let satelliteDirectionsRenderer = null;
        let currentRouteData = null;

        async function generateSketch(from, to, route, landmarks, rivers, fromLabel, toLabel) {
            const container = document.getElementById('routeDisplay');
            container.style.display = 'block';

            // Get accurate distance from Google route
            let distanceText = '';
            let durationText = '';
            if (route.googleRoute && route.googleRoute.routes && route.googleRoute.routes[0]) {
                const leg = route.googleRoute.routes[0].legs[0];
                distanceText = leg.distance.text;
                durationText = leg.duration.text;
            } else {
                distanceText = `${(route.distance / 1000).toFixed(1)} km`;
            }

            // Update header with accurate distance
            document.getElementById('routeTitle').textContent = 'Your Route';
            document.getElementById('routeDistanceLabel').innerHTML = `${distanceText} <span style="color:#666;font-size:12px;">(${durationText})</span>`;

            // Store route data
            currentRouteData = { from, to, route, fromLabel, toLabel };

            // Initialize satellite map with route
            initSatelliteRouteMap(route);

            // Display all turn instructions
            displayAllTurnInstructions(route.steps);

            container.scrollIntoView({ behavior: 'smooth' });
        }

        let nearbyRoadsPolylines = [];

        function initSatelliteRouteMap(route) {
            const mapDiv = document.getElementById('satelliteRouteMap');

            if (!satelliteRouteMap) {
                satelliteRouteMap = new google.maps.Map(mapDiv, {
                    center: { lat: route.bbox.minLat, lng: route.bbox.minLng },
                    zoom: 14,
                    mapTypeId: 'hybrid', // Satellite with labels
                    mapTypeControl: true,
                    mapTypeControlOptions: {
                        style: google.maps.MapTypeControlStyle.HORIZONTAL_BAR,
                        position: google.maps.ControlPosition.TOP_RIGHT,
                        mapTypeIds: ['roadmap', 'satellite', 'hybrid', 'terrain']
                    },
                    zoomControl: true,
                    streetViewControl: false,
                    fullscreenControl: true,
                    maxZoom: 21
                });

                satelliteDirectionsRenderer = new google.maps.DirectionsRenderer({
                    suppressMarkers: false,
                    preserveViewport: false,
                    polylineOptions: {
                        strokeColor: '#4285F4',
                        strokeWeight: 6,
                        strokeOpacity: 0.9
                    }
                });
                satelliteDirectionsRenderer.setMap(satelliteRouteMap);

                // Add compass/North indicator
                addCompassControl(satelliteRouteMap);
            }

            // Show the route with alternatives
            if (route.googleRoute) {
                satelliteDirectionsRenderer.setDirections(route.googleRoute);

                // Show alternative routes as gray lines
                showAlternativeRoutes(route.googleRoute);
            }

            // Fetch and show nearby roads as yellow lines
            fetchNearbyRoads(route.bbox, route.coordinates);
        }

        let alternativeRenderers = [];

        function showAlternativeRoutes(directionsResult) {
            // Clear previous alternative renderers
            alternativeRenderers.forEach(r => r.setMap(null));
            alternativeRenderers = [];

            // If there are alternative routes, display them
            if (directionsResult.routes && directionsResult.routes.length > 1) {
                for (let i = 1; i < directionsResult.routes.length; i++) {
                    const altRenderer = new google.maps.DirectionsRenderer({
                        map: satelliteRouteMap,
                        directions: directionsResult,
                        routeIndex: i,
                        suppressMarkers: true,
                        preserveViewport: true,
                        polylineOptions: {
                            strokeColor: '#888888', // Gray for alternatives
                            strokeWeight: 4,
                            strokeOpacity: 0.6
                        }
                    });
                    alternativeRenderers.push(altRenderer);
                }

                // Show info about alternatives
                const numAlts = directionsResult.routes.length - 1;
                console.log(`Found ${numAlts} alternative route(s)`);
            }
        }

        async function fetchNearbyRoads(bbox, routeCoords) {
            // Clear existing nearby road polylines
            nearbyRoadsPolylines.forEach(p => p.setMap(null));
            nearbyRoadsPolylines = [];

            const padding = 0.005;
            const query = `
                [out:json][timeout:25];
                (
                    way["highway"~"primary|secondary|tertiary|residential|unclassified"](${bbox.minLat - padding},${bbox.minLng - padding},${bbox.maxLat + padding},${bbox.maxLng + padding});
                );
                out geom 100;
            `;

            try {
                const response = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    body: query
                });
                const data = await response.json();

                // Draw each road as yellow polyline
                data.elements.forEach(way => {
                    if (way.geometry && way.geometry.length > 1) {
                        const path = way.geometry.map(p => ({ lat: p.lat, lng: p.lon }));

                        // Check if this road is not the main route (avoid duplicating blue line)
                        if (!isPartOfMainRoute(path, routeCoords)) {
                            const polyline = new google.maps.Polyline({
                                path: path,
                                strokeColor: '#FFD700', // Yellow/Gold
                                strokeOpacity: 0.7,
                                strokeWeight: 3,
                                map: satelliteRouteMap,
                                zIndex: 1
                            });
                            nearbyRoadsPolylines.push(polyline);
                        }
                    }
                });
            } catch (e) {
                console.log('Could not fetch nearby roads:', e);
            }
        }

        function isPartOfMainRoute(roadPath, routeCoords) {
            // Check if road significantly overlaps with main route
            let matchCount = 0;
            for (let i = 0; i < roadPath.length; i++) {
                for (let j = 0; j < routeCoords.length; j++) {
                    const dist = Math.sqrt(
                        Math.pow(roadPath[i].lat - routeCoords[j].lat, 2) +
                        Math.pow(roadPath[i].lng - routeCoords[j].lng, 2)
                    );
                    if (dist < 0.0003) { // Very close (~30m)
                        matchCount++;
                        break;
                    }
                }
            }
            // If more than 50% of road matches route, it's the main route
            return matchCount > roadPath.length * 0.5;
        }

        function addCompassControl(map) {
            // Create compass div
            const compassDiv = document.createElement('div');
            compassDiv.style.cssText = `
                background: rgba(255,255,255,0.95);
                border-radius: 50%;
                width: 50px;
                height: 50px;
                margin: 10px;
                box-shadow: 0 2px 6px rgba(0,0,0,0.3);
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
            `;
            compassDiv.title = 'Click to reset North';

            compassDiv.innerHTML = `
                <svg width="40" height="40" viewBox="0 0 40 40">
                    <circle cx="20" cy="20" r="18" fill="none" stroke="#ddd" stroke-width="2"/>
                    <polygon points="20,4 24,20 20,16 16,20" fill="#e74c3c"/>
                    <polygon points="20,36 24,20 20,24 16,20" fill="#333"/>
                    <text x="20" y="9" text-anchor="middle" font-size="8" font-weight="bold" fill="#e74c3c">N</text>
                    <text x="20" y="38" text-anchor="middle" font-size="7" fill="#666">S</text>
                    <text x="5" y="22" text-anchor="middle" font-size="7" fill="#666">W</text>
                    <text x="35" y="22" text-anchor="middle" font-size="7" fill="#666">E</text>
                </svg>
            `;

            // Click to reset heading to North
            compassDiv.addEventListener('click', () => {
                map.setHeading(0);
            });

            map.controls[google.maps.ControlPosition.LEFT_BOTTOM].push(compassDiv);
        }

        let stepMarkers = [];
        let keyNavigationPoints = [];

        function displayAllTurnInstructions(steps) {
            const container = document.getElementById('turnStepsList');

            if (!steps || steps.length === 0) {
                container.innerHTML = '<div style="text-align:center;color:#666;padding:20px;">No directions available</div>';
                return;
            }

            // Extract only 5 key navigation points
            keyNavigationPoints = extract5KeyPoints(steps);

            // Clear existing markers
            stepMarkers.forEach(m => m.setMap(null));
            stepMarkers = [];

            let html = '<div class="key-points-title">5 Key Navigation Points (Top View)</div>';

            keyNavigationPoints.forEach((point, index) => {
                const { step, instruction, icon, location } = point;
                const distance = step.distance ? step.distance.text : '';

                // Add marker on map
                if (location) {
                    const marker = new google.maps.Marker({
                        position: { lat: location.lat(), lng: location.lng() },
                        map: satelliteRouteMap,
                        label: {
                            text: String(index + 1),
                            color: 'white',
                            fontWeight: 'bold'
                        },
                        icon: {
                            path: google.maps.SymbolPath.CIRCLE,
                            scale: 15,
                            fillColor: index === 0 ? '#22c55e' : index === 4 ? '#ef4444' : '#4285F4',
                            fillOpacity: 1,
                            strokeColor: 'white',
                            strokeWeight: 2
                        },
                        title: `Step ${index + 1}: ${instruction}`
                    });
                    stepMarkers.push(marker);
                }

                html += `
                    <div class="turn-step" onclick="navigateToKeyPoint(${index})" data-step="${index}">
                        <div class="step-number" style="background:${index === 0 ? '#22c55e' : index === 4 ? '#ef4444' : '#4285F4'}">${index + 1}</div>
                        <div class="step-icon">${icon}</div>
                        <div class="step-content">
                            <div class="step-instruction">${instruction}</div>
                            <div class="step-distance">${distance}</div>
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        function extract5KeyPoints(steps) {
            if (steps.length <= 5) {
                return steps.map((step, i) => formatStep(step, i, steps.length, i === steps.length - 1));
            }

            // Always include first and last
            const points = [];

            // Point 1: Start
            points.push(formatStep(steps[0], 0, steps.length, false));

            // Points 2, 3, 4: Key turns in between (evenly distributed)
            const middleSteps = steps.slice(1, -1);
            const interval = Math.floor(middleSteps.length / 3);

            for (let i = 0; i < 3 && i * interval < middleSteps.length; i++) {
                const idx = Math.min(i * interval + Math.floor(interval / 2), middleSteps.length - 1);
                points.push(formatStep(middleSteps[idx], idx + 1, steps.length, false));
            }

            // Point 5: Destination - use end_location for actual destination
            points.push(formatStep(steps[steps.length - 1], steps.length - 1, steps.length, true));

            // Ensure we have exactly 5 points
            while (points.length < 5 && steps.length > points.length) {
                const idx = Math.floor(steps.length / 2);
                points.splice(2, 0, formatStep(steps[idx], idx, steps.length, false));
            }

            return points.slice(0, 5);
        }

        function formatStep(step, index, totalSteps, isDestination = false) {
            const instruction = step.instructions ? step.instructions.replace(/<[^>]*>/g, '') : 'Continue';
            const lowerInstr = instruction.toLowerCase();

            let icon = '‚û°Ô∏è';
            if (index === 0) icon = 'üö©';
            else if (isDestination || lowerInstr.includes('destination')) icon = 'üè†';
            else if (lowerInstr.includes('left')) icon = '‚Ü∞';
            else if (lowerInstr.includes('right')) icon = '‚Ü±';
            else if (lowerInstr.includes('straight') || lowerInstr.includes('continue')) icon = '‚¨ÜÔ∏è';
            else if (lowerInstr.includes('roundabout')) icon = 'üîÑ';

            // For destination, use end_location to show actual destination point
            const location = isDestination ? (step.end_location || step.start_location) : (step.start_location || step.end_location);

            return {
                step,
                instruction,
                icon,
                location
            };
        }

        function navigateToKeyPoint(pointIndex) {
            if (!keyNavigationPoints[pointIndex]) return;

            const point = keyNavigationPoints[pointIndex];
            if (point.location) {
                // Zoom to this point from top view
                satelliteRouteMap.setCenter({ lat: point.location.lat(), lng: point.location.lng() });
                satelliteRouteMap.setZoom(18); // High zoom top view
                satelliteRouteMap.setTilt(0); // Top view (no tilt)
                satelliteRouteMap.setHeading(0); // North up
            }

            // Highlight active step
            document.querySelectorAll('.turn-step').forEach(el => el.classList.remove('active'));
            document.querySelector(`.turn-step[data-step="${pointIndex}"]`)?.classList.add('active');
        }

        // Service Worker
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js').catch(() => {});
        }
    </script>
</body>
</html>
