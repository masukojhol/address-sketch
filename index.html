<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Sketch">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#4a90d9">

    <title>Address Sketch - Auto Route Generator</title>
    <meta name="description" content="Generate simple address sketches from any location. Enter FROM and TO, get an easy-to-draw route map with landmarks.">

    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/svg+xml" href="icons/icon.svg">

    <!-- Google Maps API -->
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAcYZaAgnCQCJx4y848ezC32_7PYTkjWBM&libraries=places"></script>

    <!-- Google AdSense -->
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1157507558678597" crossorigin="anonymous"></script>

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        html, body { overflow-x: hidden; overscroll-behavior: none; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f0f2f5;
            min-height: 100vh;
        }

        .header {
            background: linear-gradient(135deg, #4a90d9, #357abd);
            color: white;
            padding: 12px 16px;
            padding-top: max(12px, env(safe-area-inset-top));
            text-align: center;
        }
        .header h1 { font-size: 18px; font-weight: 600; }
        .header p { font-size: 12px; opacity: 0.9; margin-top: 4px; }

        .main-container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 12px;
        }

        /* Tab Navigation */
        .tabs {
            display: flex;
            background: #fff;
            border-radius: 12px;
            padding: 6px;
            margin-bottom: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }
        .tab-btn {
            flex: 1;
            padding: 12px;
            border: none;
            background: transparent;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        .tab-btn.active {
            background: #4a90d9;
            color: white;
        }

        .tab-content { display: none; }
        .tab-content.active { display: block; }

        /* Route Generator */
        .route-panel {
            background: #fff;
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            margin-bottom: 12px;
        }
        .input-group {
            margin-bottom: 12px;
        }
        .input-group label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: #666;
            margin-bottom: 6px;
        }
        .input-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 15px;
            outline: none;
            transition: border-color 0.2s;
        }
        .input-group input:focus { border-color: #4a90d9; }
        .input-hint {
            font-size: 11px;
            color: #999;
            margin-top: 4px;
        }
        .input-with-btn {
            display: flex;
            gap: 8px;
        }
        .input-with-btn input {
            flex: 1;
        }
        .location-btn {
            padding: 12px 14px;
            background: #27ae60;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            white-space: nowrap;
            transition: all 0.2s;
        }
        .location-btn:active { transform: scale(0.95); }
        .location-btn:disabled { opacity: 0.6; cursor: not-allowed; }

        .generate-btn {
            width: 100%;
            padding: 14px;
            background: linear-gradient(135deg, #4a90d9, #357abd);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, opacity 0.2s;
        }
        .generate-btn:active { transform: scale(0.98); }
        .generate-btn:disabled { opacity: 0.6; cursor: not-allowed; }

        .status-msg {
            text-align: center;
            padding: 12px;
            font-size: 14px;
            color: #666;
        }
        .status-msg.error { color: #e74c3c; }

        /* Map Preview */
        .map-container {
            background: #fff;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            margin-bottom: 12px;
        }
        #map {
            height: 250px;
            width: 100%;
        }

        /* Sketch Output */
        .sketch-container {
            background: #fff;
            border-radius: 12px;
            padding: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }
        .sketch-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        .sketch-header h3 {
            font-size: 14px;
            color: #333;
        }
        #sketchCanvas {
            width: 100%;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            background: #fff;
        }

        .sketch-actions {
            display: flex;
            gap: 8px;
            margin-top: 12px;
            flex-wrap: wrap;
        }
        .sketch-actions button {
            flex: 1;
            min-width: 100px;
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
        }
        .btn-primary { background: #4a90d9; color: white; }
        .btn-secondary { background: #e0e0e0; color: #333; }
        .btn-danger { background: #e74c3c; color: white; }

        /* Manual Draw Tab */
        .toolbar {
            background: #fff;
            padding: 10px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            margin-bottom: 12px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }
        .tool-group {
            display: flex;
            gap: 4px;
            align-items: center;
        }
        .tool-group.separator {
            padding-right: 10px;
            border-right: 1px solid #eee;
            margin-right: 2px;
        }
        .tool-btn {
            width: 40px;
            height: 40px;
            border: 2px solid #e0e0e0;
            background: #fff;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
        }
        .tool-btn:active { transform: scale(0.95); }
        .tool-btn.active {
            background: #4a90d9;
            border-color: #4a90d9;
            color: white;
        }
        .color-btn {
            width: 28px;
            height: 28px;
            padding: 0;
            border-radius: 50%;
            border: 3px solid transparent;
        }
        .color-btn.active { border-color: #333; transform: scale(1.1); }

        .canvas-wrapper {
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            padding: 8px;
        }
        #drawCanvas {
            display: block;
            width: 100%;
            border-radius: 8px;
            background: #fff;
            touch-action: none;
        }

        .landmarks {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            padding: 10px 0;
            border-top: 1px solid #eee;
            margin-top: 10px;
        }
        .landmark-btn {
            padding: 6px 10px;
            border: 1px solid #e0e0e0;
            background: #fafafa;
            border-radius: 16px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .landmark-btn:active { background: #4a90d9; color: white; border-color: #4a90d9; }
        .landmark-btn span { font-size: 14px; }

        .actions {
            display: flex;
            gap: 8px;
            padding-top: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        /* Legend */
        .legend {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 12px;
            margin-top: 12px;
            font-size: 12px;
        }
        .legend h4 { margin-bottom: 8px; color: #333; }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }
        .legend-icon {
            width: 20px;
            text-align: center;
        }

        /* Ads */
        .ad-container {
            background: #e0e0e0;
            border-radius: 8px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #999;
            font-size: 11px;
            margin-bottom: 12px;
        }

        .footer {
            text-align: center;
            padding: 15px;
            color: #888;
            font-size: 11px;
        }

        /* Loading */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .spinner {
            width: 20px;
            height: 20px;
            border: 3px solid #e0e0e0;
            border-top-color: #4a90d9;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        @media (max-width: 600px) {
            .header h1 { font-size: 16px; }
            .tool-btn { width: 36px; height: 36px; font-size: 14px; }
            .color-btn { width: 24px; height: 24px; }
        }

        @media print {
            .header, .tabs, .route-panel, .toolbar, .landmarks, .actions,
            .sketch-actions, .map-container, .ad-container, .footer, .legend { display: none !important; }
            .sketch-container, .canvas-wrapper { box-shadow: none; padding: 0; }
            #sketchCanvas, #drawCanvas { border: 1px solid #ccc; }
        }
    </style>
</head>
<body>
    <header class="header">
        <h1>Address Sketch Tool</h1>
        <p>Generate route sketches for bank forms</p>
    </header>

    <div class="main-container">
        <!-- Top Ad -->
        <div class="ad-container">
            <ins class="adsbygoogle" style="display:block" data-ad-format="auto"
                data-full-width-responsive="true" data-ad-client="ca-pub-1157507558678597"
                data-ad-slot="XXXXXXXXXX"></ins>
        </div>

        <!-- Tabs -->
        <div class="tabs">
            <button class="tab-btn active" onclick="switchTab('auto')">Auto Generate</button>
            <button class="tab-btn" onclick="switchTab('manual')">Manual Draw</button>
        </div>

        <!-- Auto Generate Tab -->
        <div id="autoTab" class="tab-content active">
            <div class="route-panel">
                <div class="input-group">
                    <label>üìç FROM (Your Current Location)</label>
                    <div class="input-with-btn">
                        <input type="text" id="fromLocation" placeholder="Click 'Use My Location' or select on map">
                        <button class="location-btn" id="getLocationBtn" onclick="getCurrentLocation()">üìç My Location</button>
                        <button class="location-btn" style="background:#3498db;" onclick="openMapPicker('from')">üó∫Ô∏è Map</button>
                    </div>
                    <div class="input-hint" id="locationHint">Auto-detecting your location...</div>
                </div>
                <div class="input-group">
                    <label>üè† TO (Your Destination)</label>
                    <div class="input-with-btn">
                        <input type="text" id="toLocation" placeholder="Enter address or select on map">
                        <button class="location-btn" style="background:#3498db;" onclick="openMapPicker('to')">üó∫Ô∏è Select on Map</button>
                    </div>
                    <div class="input-hint" id="toHint">Enter address or pick location on map</div>
                </div>
                <button class="generate-btn" id="generateBtn" onclick="generateRoute()">
                    Generate Route Sketch
                </button>
                <div class="status-msg" id="statusMsg"></div>
            </div>

            <!-- Map Preview -->
            <div class="map-container" id="mapContainer" style="display:none;">
                <div id="map"></div>
            </div>

            <!-- Sketch Output -->
            <div class="sketch-container" id="sketchContainer" style="display:none;">
                <div class="sketch-header">
                    <h3>üìù Simplified Sketch (Easy to Draw on Paper)</h3>
                </div>
                <canvas id="sketchCanvas" width="800" height="500"></canvas>
                <div class="sketch-actions">
                    <button class="btn-primary" onclick="saveSketch()">üíæ Save Image</button>
                    <button class="btn-secondary" onclick="window.print()">üñ®Ô∏è Print</button>
                    <button class="btn-secondary" onclick="regenerate()">üîÑ Regenerate</button>
                </div>
                <div class="legend">
                    <h4>Legend (for drawing on paper):</h4>
                    <div class="legend-item"><span class="legend-icon">‚îÅ‚îÅ</span> Main Road</div>
                    <div class="legend-item"><span class="legend-icon">‚óè</span> Turn Point</div>
                    <div class="legend-item"><span class="legend-icon">üè†</span> Your Home</div>
                    <div class="legend-item"><span class="legend-icon">üè¶</span> Starting Point (Bank)</div>
                    <div class="legend-item"><span class="legend-icon">‚≠ê</span> Landmark</div>
                </div>
            </div>
        </div>

        <!-- Manual Draw Tab -->
        <div id="manualTab" class="tab-content">
            <div class="toolbar">
                <div class="tool-group separator">
                    <button class="tool-btn active" data-tool="pen">‚úèÔ∏è</button>
                    <button class="tool-btn" data-tool="line">üìè</button>
                    <button class="tool-btn" data-tool="text">üî§</button>
                    <button class="tool-btn" data-tool="eraser">üßΩ</button>
                </div>
                <div class="tool-group separator">
                    <button class="color-btn active" style="background:#000" data-color="#000"></button>
                    <button class="color-btn" style="background:#e74c3c" data-color="#e74c3c"></button>
                    <button class="color-btn" style="background:#27ae60" data-color="#27ae60"></button>
                    <button class="color-btn" style="background:#3498db" data-color="#3498db"></button>
                </div>
                <div class="tool-group">
                    <input type="range" id="sizeSlider" min="1" max="10" value="2" style="width:70px;">
                </div>
            </div>

            <div class="canvas-wrapper">
                <canvas id="drawCanvas" width="800" height="450"></canvas>
                <div class="landmarks">
                    <button class="landmark-btn" data-emoji="üè†"><span>üè†</span>Home</button>
                    <button class="landmark-btn" data-emoji="üè¶"><span>üè¶</span>Bank</button>
                    <button class="landmark-btn" data-emoji="üè•"><span>üè•</span>Hospital</button>
                    <button class="landmark-btn" data-emoji="‚õ™"><span>‚õ™</span>Temple</button>
                    <button class="landmark-btn" data-emoji="üïå"><span>üïå</span>Mosque</button>
                    <button class="landmark-btn" data-emoji="üè´"><span>üè´</span>School</button>
                    <button class="landmark-btn" data-emoji="üè™"><span>üè™</span>Shop</button>
                    <button class="landmark-btn" data-emoji="‚õΩ"><span>‚õΩ</span>Petrol</button>
                    <button class="landmark-btn" data-emoji="üöâ"><span>üöâ</span>Station</button>
                    <button class="landmark-btn" data-emoji="üö¶"><span>üö¶</span>Signal</button>
                    <button class="landmark-btn" data-emoji="üå≥"><span>üå≥</span>Park</button>
                    <button class="landmark-btn" data-emoji="‚≠ê"><span>‚≠ê</span>Mark</button>
                </div>
                <div class="actions">
                    <button class="btn-secondary" onclick="undoDraw()">‚Ü©Ô∏è Undo</button>
                    <button class="btn-primary" onclick="saveDrawing()">üíæ Save</button>
                    <button class="btn-secondary" onclick="window.print()">üñ®Ô∏è Print</button>
                    <button class="btn-danger" onclick="clearDrawing()">üóëÔ∏è Clear</button>
                </div>
            </div>
        </div>

        <!-- Bottom Ad -->
        <div class="ad-container">
            <ins class="adsbygoogle" style="display:block" data-ad-format="auto"
                data-full-width-responsive="true" data-ad-client="ca-pub-1157507558678597"
                data-ad-slot="XXXXXXXXXX"></ins>
        </div>
    </div>

    <footer class="footer">
        Address Sketch Tool - Generate route maps for bank forms & documents
    </footer>

    <!-- Text Modal -->
    <div class="modal-overlay" id="textModal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.5);justify-content:center;align-items:center;z-index:100;">
        <div style="background:white;padding:20px;border-radius:12px;width:90%;max-width:300px;">
            <h3 style="margin-bottom:12px;font-size:16px;">Add Label</h3>
            <input type="text" id="textInput" placeholder="Enter text..." maxlength="30" style="width:100%;padding:12px;border:2px solid #e0e0e0;border-radius:8px;font-size:15px;margin-bottom:12px;">
            <div style="display:flex;gap:10px;">
                <button onclick="closeTextModal()" style="flex:1;padding:10px;border:none;background:#e0e0e0;border-radius:8px;cursor:pointer;">Cancel</button>
                <button onclick="addText()" style="flex:1;padding:10px;border:none;background:#4a90d9;color:white;border-radius:8px;cursor:pointer;">Add</button>
            </div>
        </div>
    </div>

    <!-- Map Picker Modal -->
    <div id="mapPickerModal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.8);z-index:200;">
        <div style="height:100%;display:flex;flex-direction:column;">
            <div style="background:#4a90d9;color:white;padding:15px;display:flex;justify-content:space-between;align-items:center;">
                <h3 style="font-size:16px;" id="mapPickerTitle">Select Location on Map</h3>
                <button onclick="closeMapPicker()" style="background:none;border:none;color:white;font-size:24px;cursor:pointer;">√ó</button>
            </div>
            <div style="padding:10px;background:#fff;">
                <input type="text" id="mapSearchInput" placeholder="Search location..." style="width:100%;padding:12px;border:2px solid #e0e0e0;border-radius:8px;font-size:15px;">
            </div>
            <div id="pickerMap" style="flex:1;"></div>
            <div style="background:#fff;padding:15px;">
                <div id="selectedLocationText" style="font-size:13px;color:#666;margin-bottom:10px;min-height:20px;">Tap on map to select location</div>
                <div style="display:flex;gap:10px;">
                    <button onclick="closeMapPicker()" style="flex:1;padding:12px;border:none;background:#e0e0e0;border-radius:8px;cursor:pointer;font-size:14px;">Cancel</button>
                    <button onclick="confirmMapSelection()" id="confirmMapBtn" style="flex:1;padding:12px;border:none;background:#27ae60;color:white;border-radius:8px;cursor:pointer;font-size:14px;" disabled>Confirm Location</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ==================== TAB SWITCHING ====================
        function switchTab(tab) {
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));

            if (tab === 'auto') {
                document.querySelector('.tab-btn:nth-child(1)').classList.add('active');
                document.getElementById('autoTab').classList.add('active');
            } else {
                document.querySelector('.tab-btn:nth-child(2)').classList.add('active');
                document.getElementById('manualTab').classList.add('active');
                initDrawCanvas();
            }
        }

        // ==================== AUTO ROUTE GENERATOR ====================
        let map = null;
        let routeData = null;
        let landmarks = [];
        let currentLocationCoords = null;
        let directionsService = null;
        let directionsRenderer = null;

        // Map Picker variables
        let pickerMap = null;
        let pickerMarker = null;
        let pickerTarget = null; // 'from' or 'to'
        let selectedPickerCoords = null;
        let selectedPickerAddress = null;
        let placesAutocomplete = null;

        // Get current location on page load
        window.addEventListener('load', () => {
            getCurrentLocation();
        });

        // ==================== MAP PICKER (Google Maps) ====================
        function openMapPicker(target) {
            pickerTarget = target;
            selectedPickerCoords = null;
            selectedPickerAddress = null;

            const modal = document.getElementById('mapPickerModal');
            const title = document.getElementById('mapPickerTitle');
            const confirmBtn = document.getElementById('confirmMapBtn');
            const selectedText = document.getElementById('selectedLocationText');

            title.textContent = target === 'from' ? 'Select FROM Location' : 'Select TO Location';
            selectedText.textContent = 'Tap on map to select location';
            confirmBtn.disabled = true;
            modal.style.display = 'block';

            // Initialize or reset picker map
            setTimeout(() => {
                if (!pickerMap) {
                    const mapOptions = {
                        center: { lat: 20.5937, lng: 78.9629 }, // India center
                        zoom: 5,
                        mapTypeControl: false,
                        streetViewControl: false,
                        fullscreenControl: false
                    };
                    pickerMap = new google.maps.Map(document.getElementById('pickerMap'), mapOptions);

                    // Click to select location
                    pickerMap.addListener('click', (e) => {
                        selectLocationOnMap(e.latLng.lat(), e.latLng.lng());
                    });

                    // Setup Places Autocomplete
                    const searchInput = document.getElementById('mapSearchInput');
                    placesAutocomplete = new google.maps.places.Autocomplete(searchInput, {
                        fields: ['geometry', 'formatted_address', 'name']
                    });
                    placesAutocomplete.addListener('place_changed', () => {
                        const place = placesAutocomplete.getPlace();
                        if (place.geometry) {
                            const lat = place.geometry.location.lat();
                            const lng = place.geometry.location.lng();
                            pickerMap.setCenter({ lat, lng });
                            pickerMap.setZoom(16);
                            selectLocationOnMap(lat, lng, place.formatted_address || place.name);
                        }
                    });
                }

                // If we have current location, center there
                if (currentLocationCoords && target === 'from') {
                    pickerMap.setCenter({ lat: currentLocationCoords.lat, lng: currentLocationCoords.lng });
                    pickerMap.setZoom(15);
                } else if (currentLocationCoords) {
                    pickerMap.setCenter({ lat: currentLocationCoords.lat, lng: currentLocationCoords.lng });
                    pickerMap.setZoom(13);
                }

                // Remove existing marker
                if (pickerMarker) {
                    pickerMarker.setMap(null);
                    pickerMarker = null;
                }

                // Clear search input
                document.getElementById('mapSearchInput').value = '';
            }, 100);
        }

        async function selectLocationOnMap(lat, lng, address = null) {
            selectedPickerCoords = { lat, lng };

            // Update marker
            if (pickerMarker) {
                pickerMarker.setMap(null);
            }
            pickerMarker = new google.maps.Marker({
                position: { lat, lng },
                map: pickerMap,
                animation: google.maps.Animation.DROP
            });

            // Reverse geocode
            const selectedText = document.getElementById('selectedLocationText');
            const confirmBtn = document.getElementById('confirmMapBtn');

            if (address) {
                selectedPickerAddress = address;
                selectedText.textContent = address;
                confirmBtn.disabled = false;
                return;
            }

            selectedText.textContent = 'Getting address...';

            const geocoder = new google.maps.Geocoder();
            geocoder.geocode({ location: { lat, lng } }, (results, status) => {
                if (status === 'OK' && results[0]) {
                    selectedPickerAddress = results[0].formatted_address;
                    selectedText.textContent = selectedPickerAddress;
                } else {
                    selectedPickerAddress = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
                    selectedText.textContent = selectedPickerAddress;
                }
                confirmBtn.disabled = false;
            });
        }

        function confirmMapSelection() {
            if (!selectedPickerCoords || !selectedPickerAddress) return;

            if (pickerTarget === 'from') {
                document.getElementById('fromLocation').value = selectedPickerAddress;
                document.getElementById('locationHint').textContent = '‚úì Location selected from map';
                document.getElementById('locationHint').style.color = '#27ae60';
                currentLocationCoords = selectedPickerCoords;
            } else {
                document.getElementById('toLocation').value = selectedPickerAddress;
                document.getElementById('toHint').textContent = '‚úì Location selected from map';
                document.getElementById('toHint').style.color = '#27ae60';
            }

            closeMapPicker();
        }

        function closeMapPicker() {
            document.getElementById('mapPickerModal').style.display = 'none';
        }

        async function getCurrentLocation() {
            const btn = document.getElementById('getLocationBtn');
            const input = document.getElementById('fromLocation');
            const hint = document.getElementById('locationHint');

            if (!navigator.geolocation) {
                hint.textContent = 'Geolocation not supported. Enter address manually.';
                hint.style.color = '#e74c3c';
                return;
            }

            btn.disabled = true;
            btn.textContent = 'üìç Locating...';
            hint.textContent = 'Getting your location...';

            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;
                    currentLocationCoords = { lat, lng };

                    // Reverse geocode using Google
                    const geocoder = new google.maps.Geocoder();
                    geocoder.geocode({ location: { lat, lng } }, (results, status) => {
                        if (status === 'OK' && results[0]) {
                            input.value = results[0].formatted_address;
                            hint.textContent = '‚úì Location detected! You can edit if needed.';
                            hint.style.color = '#27ae60';
                        } else {
                            input.value = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
                            hint.textContent = '‚úì Coordinates detected';
                            hint.style.color = '#27ae60';
                        }
                        btn.disabled = false;
                        btn.textContent = 'üìç My Location';
                    });
                },
                (error) => {
                    btn.disabled = false;
                    btn.textContent = 'üìç Try Again';
                    hint.style.color = '#e74c3c';

                    switch (error.code) {
                        case error.PERMISSION_DENIED:
                            hint.textContent = 'Location access denied. Enter address manually.';
                            break;
                        case error.POSITION_UNAVAILABLE:
                            hint.textContent = 'Location unavailable. Enter address manually.';
                            break;
                        case error.TIMEOUT:
                            hint.textContent = 'Location timeout. Try again or enter manually.';
                            break;
                        default:
                            hint.textContent = 'Could not get location. Enter address manually.';
                    }
                },
                { enableHighAccuracy: true, timeout: 10000, maximumAge: 60000 }
            );
        }

        async function generateRoute() {
            const from = document.getElementById('fromLocation').value.trim();
            const to = document.getElementById('toLocation').value.trim();
            const statusMsg = document.getElementById('statusMsg');
            const generateBtn = document.getElementById('generateBtn');

            if (!from || !to) {
                statusMsg.textContent = 'Please enter both FROM and TO locations';
                statusMsg.className = 'status-msg error';
                return;
            }

            generateBtn.disabled = true;
            generateBtn.innerHTML = '<span class="loading"><span class="spinner"></span> Generating...</span>';
            statusMsg.textContent = '';

            try {
                // Step 1: Geocode both locations
                statusMsg.textContent = 'Finding locations...';
                const [fromCoords, toCoords] = await Promise.all([
                    geocode(from),
                    geocode(to)
                ]);

                if (!fromCoords || !toCoords) {
                    throw new Error('Could not find one or both locations. Try more specific addresses.');
                }

                // Step 2: Get route
                statusMsg.textContent = 'Calculating route...';
                const route = await getRoute(fromCoords, toCoords);

                if (!route) {
                    throw new Error('Could not find a route between these locations.');
                }

                // Step 3: Get landmarks along route
                statusMsg.textContent = 'Finding landmarks...';
                landmarks = await getLandmarks(route.bbox);

                // Step 4: Show map
                showMap(fromCoords, toCoords, route);

                // Step 5: Generate simplified sketch
                statusMsg.textContent = 'Drawing sketch...';
                await generateSketch(fromCoords, toCoords, route, landmarks, from, to);

                statusMsg.textContent = 'Route generated! Scroll down to see the sketch.';
                statusMsg.className = 'status-msg';

            } catch (error) {
                statusMsg.textContent = error.message;
                statusMsg.className = 'status-msg error';
            } finally {
                generateBtn.disabled = false;
                generateBtn.innerHTML = 'Generate Route Sketch';
            }
        }

        async function geocode(address) {
            return new Promise((resolve) => {
                const geocoder = new google.maps.Geocoder();
                geocoder.geocode({ address: address }, (results, status) => {
                    if (status === 'OK' && results[0]) {
                        resolve({
                            lat: results[0].geometry.location.lat(),
                            lng: results[0].geometry.location.lng(),
                            name: results[0].formatted_address
                        });
                    } else {
                        resolve(null);
                    }
                });
            });
        }

        async function getRoute(from, to) {
            return new Promise((resolve) => {
                if (!directionsService) {
                    directionsService = new google.maps.DirectionsService();
                }

                directionsService.route({
                    origin: { lat: from.lat, lng: from.lng },
                    destination: { lat: to.lat, lng: to.lng },
                    travelMode: google.maps.TravelMode.DRIVING
                }, (result, status) => {
                    if (status === 'OK' && result.routes && result.routes.length > 0) {
                        const route = result.routes[0];
                        const leg = route.legs[0];
                        const path = route.overview_path;

                        // Extract coordinates
                        const coords = path.map(p => ({ lat: p.lat(), lng: p.lng() }));

                        // Calculate bounding box
                        let minLat = Infinity, maxLat = -Infinity;
                        let minLng = Infinity, maxLng = -Infinity;

                        coords.forEach(c => {
                            minLng = Math.min(minLng, c.lng);
                            maxLng = Math.max(maxLng, c.lng);
                            minLat = Math.min(minLat, c.lat);
                            maxLat = Math.max(maxLat, c.lat);
                        });

                        resolve({
                            coordinates: coords,
                            steps: leg.steps,
                            distance: leg.distance.value,
                            duration: leg.duration.value,
                            bbox: { minLat, maxLat, minLng, maxLng },
                            googleRoute: result
                        });
                    } else {
                        resolve(null);
                    }
                });
            });
        }

        async function getLandmarks(bbox) {
            const padding = 0.002;
            const query = `
                [out:json][timeout:25];
                (
                    node["amenity"~"hospital|bank|fuel|school|place_of_worship|police"](${bbox.minLat - padding},${bbox.minLng - padding},${bbox.maxLat + padding},${bbox.maxLng + padding});
                    node["shop"~"supermarket|mall"](${bbox.minLat - padding},${bbox.minLng - padding},${bbox.maxLat + padding},${bbox.maxLng + padding});
                    node["railway"="station"](${bbox.minLat - padding},${bbox.minLng - padding},${bbox.maxLat + padding},${bbox.maxLng + padding});
                    node["highway"="traffic_signals"](${bbox.minLat - padding},${bbox.minLng - padding},${bbox.maxLat + padding},${bbox.maxLng + padding});
                );
                out body 30;
            `;

            try {
                const response = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    body: query
                });
                const data = await response.json();

                return data.elements.map(el => ({
                    lat: el.lat,
                    lng: el.lon,
                    type: el.tags.amenity || el.tags.shop || el.tags.railway || el.tags.highway,
                    name: el.tags.name || ''
                })).slice(0, 12);
            } catch (e) {
                return [];
            }
        }

        function showMap(from, to, route) {
            const mapContainer = document.getElementById('mapContainer');
            mapContainer.style.display = 'block';

            if (!map) {
                map = new google.maps.Map(document.getElementById('map'), {
                    center: { lat: from.lat, lng: from.lng },
                    zoom: 12,
                    mapTypeControl: false,
                    streetViewControl: false
                });
                directionsRenderer = new google.maps.DirectionsRenderer({
                    suppressMarkers: false,
                    polylineOptions: {
                        strokeColor: '#4a90d9',
                        strokeWeight: 5
                    }
                });
                directionsRenderer.setMap(map);
            }

            // Display route using Google Directions
            if (route.googleRoute) {
                directionsRenderer.setDirections(route.googleRoute);
            }
        }

        async function generateSketch(from, to, route, landmarks, fromLabel, toLabel) {
            const container = document.getElementById('sketchContainer');
            container.style.display = 'block';

            const canvas = document.getElementById('sketchCanvas');
            const ctx = canvas.getContext('2d');

            // Clear canvas
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const padding = 70;
            const width = canvas.width - padding * 2;
            const height = canvas.height - padding * 2;

            // Calculate bounds
            const bbox = route.bbox;
            const scaleX = width / (bbox.maxLng - bbox.minLng || 0.001);
            const scaleY = height / (bbox.maxLat - bbox.minLat || 0.001);
            const scale = Math.min(scaleX, scaleY) * 0.85;

            const centerLng = (bbox.minLng + bbox.maxLng) / 2;
            const centerLat = (bbox.minLat + bbox.maxLat) / 2;

            function toCanvas(lat, lng) {
                return {
                    x: padding + width / 2 + (lng - centerLng) * scale,
                    y: padding + height / 2 - (lat - centerLat) * scale
                };
            }

            // Simplify route
            const simplified = simplifyRoute(route.coordinates, 0.00008);

            // Draw route
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            ctx.beginPath();
            simplified.forEach((point, i) => {
                const p = toCanvas(point.lat, point.lng);
                if (i === 0) ctx.moveTo(p.x, p.y);
                else ctx.lineTo(p.x, p.y);
            });
            ctx.stroke();

            // Draw turn points
            ctx.fillStyle = '#666';
            const turns = findTurns(simplified);
            turns.forEach(turn => {
                const p = toCanvas(turn.lat, turn.lng);
                ctx.beginPath();
                ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw landmarks
            const icons = {
                'hospital': 'üè•',
                'bank': 'üè¶',
                'fuel': '‚õΩ',
                'school': 'üè´',
                'place_of_worship': '‚õ™',
                'police': 'üöî',
                'supermarket': 'üè™',
                'mall': 'üè¨',
                'station': 'üöâ',
                'traffic_signals': 'üö¶'
            };

            ctx.font = '22px Arial';
            landmarks.forEach(lm => {
                const p = toCanvas(lm.lat, lm.lng);
                const icon = icons[lm.type] || '‚≠ê';
                ctx.fillText(icon, p.x - 11, p.y + 8);

                if (lm.name) {
                    ctx.font = '9px Arial';
                    ctx.fillStyle = '#555';
                    const shortName = lm.name.length > 12 ? lm.name.substring(0, 12) + '..' : lm.name;
                    ctx.fillText(shortName, p.x - 11, p.y + 22);
                    ctx.font = '22px Arial';
                }
            });

            // Draw start and end markers
            const startP = toCanvas(from.lat, from.lng);
            const endP = toCanvas(to.lat, to.lng);

            // Start marker
            ctx.font = '30px Arial';
            ctx.fillText('üè¶', startP.x - 15, startP.y + 10);
            ctx.font = 'bold 11px Arial';
            ctx.fillStyle = '#e74c3c';
            ctx.fillText('START', startP.x - 20, startP.y + 32);

            // End marker
            ctx.font = '30px Arial';
            ctx.fillStyle = '#000';
            ctx.fillText('üè†', endP.x - 15, endP.y + 10);
            ctx.font = 'bold 11px Arial';
            ctx.fillStyle = '#27ae60';
            ctx.fillText('HOME', endP.x - 18, endP.y + 32);

            // Title
            ctx.fillStyle = '#333';
            ctx.font = 'bold 14px Arial';
            const shortFrom = fromLabel.length > 35 ? fromLabel.substring(0, 35) + '...' : fromLabel;
            const shortTo = toLabel.length > 35 ? toLabel.substring(0, 35) + '...' : toLabel;
            ctx.fillText(`Route: ${shortFrom}`, 15, 22);
            ctx.fillText(`To: ${shortTo}`, 15, 40);

            // Distance
            const distKm = (route.distance / 1000).toFixed(1);
            ctx.font = '12px Arial';
            ctx.fillStyle = '#666';
            ctx.fillText(`Distance: ~${distKm} km`, canvas.width - 120, 25);

            // Draw North arrow
            ctx.fillStyle = '#999';
            ctx.font = '14px Arial';
            ctx.fillText('N', canvas.width - 30, 60);
            ctx.beginPath();
            ctx.moveTo(canvas.width - 25, 65);
            ctx.lineTo(canvas.width - 25, 85);
            ctx.lineTo(canvas.width - 28, 78);
            ctx.moveTo(canvas.width - 25, 85);
            ctx.lineTo(canvas.width - 22, 78);
            ctx.strokeStyle = '#999';
            ctx.lineWidth = 1.5;
            ctx.stroke();

            // Store for regeneration
            routeData = { from, to, route, landmarks, fromLabel, toLabel };

            // Scroll to sketch
            container.scrollIntoView({ behavior: 'smooth' });
        }

        function simplifyRoute(coords, tolerance) {
            if (coords.length < 3) return coords;

            function perpendicularDistance(point, lineStart, lineEnd) {
                const dx = lineEnd.lng - lineStart.lng;
                const dy = lineEnd.lat - lineStart.lat;
                if (dx === 0 && dy === 0) {
                    return Math.sqrt(Math.pow(point.lng - lineStart.lng, 2) + Math.pow(point.lat - lineStart.lat, 2));
                }
                const t = ((point.lng - lineStart.lng) * dx + (point.lat - lineStart.lat) * dy) / (dx * dx + dy * dy);
                const nearestLng = lineStart.lng + t * dx;
                const nearestLat = lineStart.lat + t * dy;
                return Math.sqrt(Math.pow(point.lng - nearestLng, 2) + Math.pow(point.lat - nearestLat, 2));
            }

            function simplify(points, start, end, tolerance, result) {
                let maxDist = 0;
                let maxIndex = 0;
                for (let i = start + 1; i < end; i++) {
                    const dist = perpendicularDistance(points[i], points[start], points[end]);
                    if (dist > maxDist) {
                        maxDist = dist;
                        maxIndex = i;
                    }
                }
                if (maxDist > tolerance) {
                    simplify(points, start, maxIndex, tolerance, result);
                    result.push(points[maxIndex]);
                    simplify(points, maxIndex, end, tolerance, result);
                }
            }

            const result = [coords[0]];
            simplify(coords, 0, coords.length - 1, tolerance, result);
            result.push(coords[coords.length - 1]);
            return result;
        }

        function findTurns(coords) {
            const turns = [];
            for (let i = 1; i < coords.length - 1; i++) {
                const prev = coords[i - 1];
                const curr = coords[i];
                const next = coords[i + 1];
                const angle1 = Math.atan2(curr.lat - prev.lat, curr.lng - prev.lng);
                const angle2 = Math.atan2(next.lat - curr.lat, next.lng - curr.lng);
                let diff = Math.abs(angle1 - angle2);
                if (diff > Math.PI) diff = 2 * Math.PI - diff;
                if (diff > 0.4) turns.push(curr);
            }
            return turns;
        }

        function regenerate() {
            if (routeData) {
                generateSketch(routeData.from, routeData.to, routeData.route, routeData.landmarks, routeData.fromLabel, routeData.toLabel);
            }
        }

        function saveSketch() {
            const canvas = document.getElementById('sketchCanvas');
            const link = document.createElement('a');
            link.download = 'address-route-sketch.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        // ==================== MANUAL DRAWING ====================
        let drawCanvas, drawCtx;
        let currentTool = 'pen';
        let currentColor = '#000';
        let currentSize = 2;
        let isDrawing = false;
        let lastX = 0, lastY = 0;
        let lineStartX = 0, lineStartY = 0;
        let drawHistory = [];
        let pendingLandmark = null;
        let textPosition = null;

        function initDrawCanvas() {
            if (drawCanvas) return;

            drawCanvas = document.getElementById('drawCanvas');
            drawCtx = drawCanvas.getContext('2d');

            drawCtx.fillStyle = '#fff';
            drawCtx.fillRect(0, 0, drawCanvas.width, drawCanvas.height);
            saveDrawState();

            document.querySelectorAll('#manualTab .tool-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#manualTab .tool-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentTool = btn.dataset.tool;
                    pendingLandmark = null;
                });
            });

            document.querySelectorAll('#manualTab .color-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#manualTab .color-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentColor = btn.dataset.color;
                });
            });

            document.getElementById('sizeSlider').addEventListener('input', e => {
                currentSize = parseInt(e.target.value);
            });

            document.querySelectorAll('#manualTab .landmark-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    pendingLandmark = btn.dataset.emoji;
                });
            });

            drawCanvas.addEventListener('mousedown', startDraw);
            drawCanvas.addEventListener('mousemove', draw);
            drawCanvas.addEventListener('mouseup', endDraw);
            drawCanvas.addEventListener('mouseleave', endDraw);
            drawCanvas.addEventListener('touchstart', e => { e.preventDefault(); startDraw(e); }, { passive: false });
            drawCanvas.addEventListener('touchmove', e => { e.preventDefault(); draw(e); }, { passive: false });
            drawCanvas.addEventListener('touchend', e => { e.preventDefault(); endDraw(e); }, { passive: false });
        }

        function getDrawPos(e) {
            const rect = drawCanvas.getBoundingClientRect();
            const scaleX = drawCanvas.width / rect.width;
            const scaleY = drawCanvas.height / rect.height;
            let clientX, clientY;
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        function startDraw(e) {
            const pos = getDrawPos(e);
            if (pendingLandmark) {
                drawCtx.font = '28px Arial';
                drawCtx.fillText(pendingLandmark, pos.x - 14, pos.y + 10);
                pendingLandmark = null;
                saveDrawState();
                return;
            }
            if (currentTool === 'text') {
                textPosition = pos;
                document.getElementById('textModal').style.display = 'flex';
                document.getElementById('textInput').value = '';
                document.getElementById('textInput').focus();
                return;
            }
            isDrawing = true;
            lastX = pos.x;
            lastY = pos.y;
            lineStartX = pos.x;
            lineStartY = pos.y;
        }

        function draw(e) {
            if (!isDrawing) return;
            const pos = getDrawPos(e);
            if (currentTool === 'pen' || currentTool === 'eraser') {
                drawCtx.strokeStyle = currentTool === 'eraser' ? '#fff' : currentColor;
                drawCtx.lineWidth = currentTool === 'eraser' ? currentSize * 4 : currentSize;
                drawCtx.lineCap = 'round';
                drawCtx.beginPath();
                drawCtx.moveTo(lastX, lastY);
                drawCtx.lineTo(pos.x, pos.y);
                drawCtx.stroke();
                lastX = pos.x;
                lastY = pos.y;
            }
        }

        function endDraw(e) {
            if (!isDrawing) return;
            if (currentTool === 'line') {
                const pos = getDrawPos(e);
                drawCtx.strokeStyle = currentColor;
                drawCtx.lineWidth = currentSize;
                drawCtx.lineCap = 'round';
                drawCtx.beginPath();
                drawCtx.moveTo(lineStartX, lineStartY);
                drawCtx.lineTo(pos.x, pos.y);
                drawCtx.stroke();
            }
            isDrawing = false;
            saveDrawState();
        }

        function saveDrawState() {
            drawHistory.push(drawCanvas.toDataURL());
            if (drawHistory.length > 30) drawHistory.shift();
        }

        function undoDraw() {
            if (drawHistory.length > 1) {
                drawHistory.pop();
                const img = new Image();
                img.onload = () => {
                    drawCtx.fillStyle = '#fff';
                    drawCtx.fillRect(0, 0, drawCanvas.width, drawCanvas.height);
                    drawCtx.drawImage(img, 0, 0);
                };
                img.src = drawHistory[drawHistory.length - 1];
            }
        }

        function clearDrawing() {
            if (confirm('Clear the entire sketch?')) {
                drawCtx.fillStyle = '#fff';
                drawCtx.fillRect(0, 0, drawCanvas.width, drawCanvas.height);
                saveDrawState();
            }
        }

        function saveDrawing() {
            const link = document.createElement('a');
            link.download = 'address-sketch.png';
            link.href = drawCanvas.toDataURL('image/png');
            link.click();
        }

        function addText() {
            const text = document.getElementById('textInput').value.trim();
            if (text && textPosition) {
                drawCtx.font = `${14 + currentSize}px Arial`;
                drawCtx.fillStyle = currentColor;
                drawCtx.fillText(text, textPosition.x, textPosition.y);
                saveDrawState();
            }
            closeTextModal();
        }

        function closeTextModal() {
            document.getElementById('textModal').style.display = 'none';
            textPosition = null;
        }

        document.getElementById('textInput').addEventListener('keydown', e => {
            if (e.key === 'Enter') addText();
            if (e.key === 'Escape') closeTextModal();
        });

        // Service Worker
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js').catch(() => {});
        }
    </script>
</body>
</html>
