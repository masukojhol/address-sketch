<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Sketch">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#4a90d9">

    <title>Address Sketch - Auto Route Generator</title>
    <meta name="description" content="Generate simple address sketches from any location. Enter FROM and TO, get an easy-to-draw route map with landmarks.">

    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/svg+xml" href="icons/icon.svg">

    <!-- Google Maps API -->
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAcYZaAgnCQCJx4y848ezC32_7PYTkjWBM&libraries=places"></script>

    <!-- Google AdSense -->
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1157507558678597" crossorigin="anonymous"></script>

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        html, body { overflow-x: hidden; overscroll-behavior: none; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f0f2f5;
            min-height: 100vh;
        }

        .header {
            background: linear-gradient(135deg, #4a90d9, #357abd);
            color: white;
            padding: 12px 16px;
            padding-top: max(12px, env(safe-area-inset-top));
            text-align: center;
        }
        .header h1 { font-size: 18px; font-weight: 600; }
        .header p { font-size: 12px; opacity: 0.9; margin-top: 4px; }

        .main-container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 12px;
        }

        /* Tab Navigation */
        .tabs {
            display: flex;
            background: #fff;
            border-radius: 12px;
            padding: 6px;
            margin-bottom: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }
        .tab-btn {
            flex: 1;
            padding: 12px;
            border: none;
            background: transparent;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        .tab-btn.active {
            background: #4a90d9;
            color: white;
        }

        .tab-content { display: none; }
        .tab-content.active { display: block; }

        /* Route Generator */
        .route-panel {
            background: #fff;
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            margin-bottom: 12px;
        }
        .input-group {
            margin-bottom: 12px;
        }
        .input-group label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: #666;
            margin-bottom: 6px;
        }
        .input-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 15px;
            outline: none;
            transition: border-color 0.2s;
        }
        .input-group input:focus { border-color: #4a90d9; }
        .input-hint {
            font-size: 11px;
            color: #999;
            margin-top: 4px;
        }
        .input-with-btn {
            display: flex;
            gap: 8px;
        }
        .input-with-btn input {
            flex: 1;
        }
        .location-btn {
            padding: 12px 14px;
            background: #27ae60;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            white-space: nowrap;
            transition: all 0.2s;
        }
        .location-btn:active { transform: scale(0.95); }
        .location-btn:disabled { opacity: 0.6; cursor: not-allowed; }

        .generate-btn {
            width: 100%;
            padding: 14px;
            background: linear-gradient(135deg, #4a90d9, #357abd);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, opacity 0.2s;
        }
        .generate-btn:active { transform: scale(0.98); }
        .generate-btn:disabled { opacity: 0.6; cursor: not-allowed; }

        .status-msg {
            text-align: center;
            padding: 12px;
            font-size: 14px;
            color: #666;
        }
        .status-msg.error { color: #e74c3c; }

        /* Map Preview */
        .map-container {
            background: #fff;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            margin-bottom: 12px;
        }
        #map {
            height: 250px;
            width: 100%;
        }

        /* Route Display */
        .route-display {
            background: #1a1a2e;
            border-radius: 16px;
            padding: 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        .route-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding: 0 8px;
        }
        .route-header h3 {
            font-size: 16px;
            color: #fff;
            font-weight: 600;
        }
        .route-distance {
            font-size: 14px;
            color: #4ade80;
            font-weight: 500;
        }
        .route-canvas-wrapper {
            position: relative;
            background: linear-gradient(180deg, #0f172a 0%, #1e293b 100%);
            border-radius: 12px;
            overflow: hidden;
        }
        #routeCanvas {
            width: 100%;
            display: block;
        }
        .route-controls {
            position: absolute;
            top: 12px;
            right: 12px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .ctrl-btn {
            width: 36px;
            height: 36px;
            border: none;
            background: rgba(255,255,255,0.15);
            color: white;
            border-radius: 8px;
            font-size: 18px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.2s;
        }
        .ctrl-btn:hover {
            background: rgba(255,255,255,0.25);
        }
        .route-info {
            position: absolute;
            bottom: 12px;
            left: 12px;
            background: rgba(0,0,0,0.7);
            color: #fff;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            backdrop-filter: blur(10px);
        }
        .route-actions {
            display: flex;
            gap: 8px;
            margin-top: 12px;
            flex-wrap: wrap;
        }
        .route-actions button {
            flex: 1;
            min-width: 80px;
            padding: 12px 16px;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        .btn-primary { background: linear-gradient(135deg, #4ade80, #22c55e); color: #000; }
        .btn-primary:hover { transform: translateY(-2px); }
        .btn-secondary { background: rgba(255,255,255,0.1); color: #fff; }
        .btn-danger { background: #e74c3c; color: white; }
        .turn-instructions {
            margin-top: 12px;
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            padding: 12px;
            max-height: 150px;
            overflow-y: auto;
        }
        .turn-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            color: #e2e8f0;
            font-size: 13px;
        }
        .turn-item:last-child { border-bottom: none; }
        .turn-icon {
            width: 28px;
            height: 28px;
            background: rgba(74,222,128,0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        /* Manual Draw Tab */
        .toolbar {
            background: #fff;
            padding: 10px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            margin-bottom: 12px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }
        .tool-group {
            display: flex;
            gap: 4px;
            align-items: center;
        }
        .tool-group.separator {
            padding-right: 10px;
            border-right: 1px solid #eee;
            margin-right: 2px;
        }
        .tool-btn {
            width: 40px;
            height: 40px;
            border: 2px solid #e0e0e0;
            background: #fff;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
        }
        .tool-btn:active { transform: scale(0.95); }
        .tool-btn.active {
            background: #4a90d9;
            border-color: #4a90d9;
            color: white;
        }
        .color-btn {
            width: 28px;
            height: 28px;
            padding: 0;
            border-radius: 50%;
            border: 3px solid transparent;
        }
        .color-btn.active { border-color: #333; transform: scale(1.1); }

        .canvas-wrapper {
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            padding: 8px;
        }
        #drawCanvas {
            display: block;
            width: 100%;
            border-radius: 8px;
            background: #fff;
            touch-action: none;
        }

        .landmarks {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            padding: 10px 0;
            border-top: 1px solid #eee;
            margin-top: 10px;
        }
        .landmark-btn {
            padding: 6px 10px;
            border: 1px solid #e0e0e0;
            background: #fafafa;
            border-radius: 16px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .landmark-btn:active { background: #4a90d9; color: white; border-color: #4a90d9; }
        .landmark-btn span { font-size: 14px; }

        .actions {
            display: flex;
            gap: 8px;
            padding-top: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        /* Legend */
        .legend {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 12px;
            margin-top: 12px;
            font-size: 12px;
        }
        .legend h4 { margin-bottom: 8px; color: #333; }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }
        .legend-icon {
            width: 20px;
            text-align: center;
        }

        /* Ads */
        .ad-container {
            background: #e0e0e0;
            border-radius: 8px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #999;
            font-size: 11px;
            margin-bottom: 12px;
        }

        .footer {
            text-align: center;
            padding: 15px;
            color: #888;
            font-size: 11px;
        }

        /* Loading */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .spinner {
            width: 20px;
            height: 20px;
            border: 3px solid #e0e0e0;
            border-top-color: #4a90d9;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        @media (max-width: 600px) {
            .header h1 { font-size: 16px; }
            .tool-btn { width: 36px; height: 36px; font-size: 14px; }
            .color-btn { width: 24px; height: 24px; }
        }

        @media print {
            .header, .tabs, .route-panel, .toolbar, .landmarks, .actions,
            .sketch-actions, .map-container, .ad-container, .footer, .legend { display: none !important; }
            .sketch-container, .canvas-wrapper { box-shadow: none; padding: 0; }
            #sketchCanvas, #drawCanvas { border: 1px solid #ccc; }
        }
    </style>
</head>
<body>
    <header class="header">
        <h1>Address Sketch Tool</h1>
        <p>Generate route sketches for bank forms</p>
    </header>

    <div class="main-container">
        <!-- Top Ad -->
        <div class="ad-container">
            <ins class="adsbygoogle" style="display:block" data-ad-format="auto"
                data-full-width-responsive="true" data-ad-client="ca-pub-1157507558678597"
                data-ad-slot="XXXXXXXXXX"></ins>
        </div>

        <!-- Tabs -->
        <div class="tabs">
            <button class="tab-btn active" onclick="switchTab('auto')">Auto Generate</button>
            <button class="tab-btn" onclick="switchTab('manual')">Manual Draw</button>
        </div>

        <!-- Auto Generate Tab -->
        <div id="autoTab" class="tab-content active">
            <div class="route-panel">
                <div class="input-group">
                    <label>üìç FROM (Your Current Location)</label>
                    <div class="input-with-btn">
                        <input type="text" id="fromLocation" placeholder="Click 'Use My Location' or select on map">
                        <button class="location-btn" id="getLocationBtn" onclick="getCurrentLocation()">üìç My Location</button>
                        <button class="location-btn" style="background:#3498db;" onclick="openMapPicker('from')">üó∫Ô∏è Map</button>
                    </div>
                    <div class="input-hint" id="locationHint">Auto-detecting your location...</div>
                </div>
                <div class="input-group">
                    <label>üè† TO (Your Destination)</label>
                    <div class="input-with-btn">
                        <input type="text" id="toLocation" placeholder="Enter address or select on map">
                        <button class="location-btn" style="background:#3498db;" onclick="openMapPicker('to')">üó∫Ô∏è Select on Map</button>
                    </div>
                    <div class="input-hint" id="toHint">Enter address or pick location on map</div>
                </div>
                <button class="generate-btn" id="generateBtn" onclick="generateRoute()">
                    Generate Route Sketch
                </button>
                <div class="status-msg" id="statusMsg"></div>
            </div>

            <!-- Map Preview -->
            <div class="map-container" id="mapContainer" style="display:none;">
                <div id="map"></div>
            </div>

            <!-- Animated Route Display -->
            <div class="route-display" id="routeDisplay" style="display:none;">
                <div class="route-header">
                    <h3 id="routeTitle">Your Route</h3>
                    <span class="route-distance" id="routeDistanceLabel"></span>
                </div>
                <div class="route-canvas-wrapper">
                    <canvas id="routeCanvas" width="900" height="600"></canvas>
                    <div class="route-controls">
                        <button class="ctrl-btn" onclick="zoomRoute(1.2)" title="Zoom In">+</button>
                        <button class="ctrl-btn" onclick="zoomRoute(0.8)" title="Zoom Out">‚àí</button>
                        <button class="ctrl-btn" onclick="resetZoom()" title="Reset">‚Ü∫</button>
                    </div>
                    <div class="route-info" id="routeInfo"></div>
                </div>
                <div class="route-actions">
                    <button class="btn-primary" onclick="replayAnimation()">‚ñ∂Ô∏è Replay</button>
                    <button class="btn-secondary" onclick="saveRoute()">üíæ Save</button>
                    <button class="btn-secondary" onclick="window.print()">üñ®Ô∏è Print</button>
                </div>
                <div class="turn-instructions" id="turnInstructions"></div>
            </div>
        </div>

        <!-- Manual Draw Tab -->
        <div id="manualTab" class="tab-content">
            <div class="toolbar">
                <div class="tool-group separator">
                    <button class="tool-btn active" data-tool="pen">‚úèÔ∏è</button>
                    <button class="tool-btn" data-tool="line">üìè</button>
                    <button class="tool-btn" data-tool="text">üî§</button>
                    <button class="tool-btn" data-tool="eraser">üßΩ</button>
                </div>
                <div class="tool-group separator">
                    <button class="color-btn active" style="background:#000" data-color="#000"></button>
                    <button class="color-btn" style="background:#e74c3c" data-color="#e74c3c"></button>
                    <button class="color-btn" style="background:#27ae60" data-color="#27ae60"></button>
                    <button class="color-btn" style="background:#3498db" data-color="#3498db"></button>
                </div>
                <div class="tool-group">
                    <input type="range" id="sizeSlider" min="1" max="10" value="2" style="width:70px;">
                </div>
            </div>

            <div class="canvas-wrapper">
                <canvas id="drawCanvas" width="800" height="450"></canvas>
                <div class="landmarks">
                    <button class="landmark-btn" data-emoji="üè†"><span>üè†</span>Home</button>
                    <button class="landmark-btn" data-emoji="üè¶"><span>üè¶</span>Bank</button>
                    <button class="landmark-btn" data-emoji="üè•"><span>üè•</span>Hospital</button>
                    <button class="landmark-btn" data-emoji="‚õ™"><span>‚õ™</span>Temple</button>
                    <button class="landmark-btn" data-emoji="üïå"><span>üïå</span>Mosque</button>
                    <button class="landmark-btn" data-emoji="üè´"><span>üè´</span>School</button>
                    <button class="landmark-btn" data-emoji="üè™"><span>üè™</span>Shop</button>
                    <button class="landmark-btn" data-emoji="‚õΩ"><span>‚õΩ</span>Petrol</button>
                    <button class="landmark-btn" data-emoji="üöâ"><span>üöâ</span>Station</button>
                    <button class="landmark-btn" data-emoji="üö¶"><span>üö¶</span>Signal</button>
                    <button class="landmark-btn" data-emoji="üå≥"><span>üå≥</span>Park</button>
                    <button class="landmark-btn" data-emoji="‚≠ê"><span>‚≠ê</span>Mark</button>
                </div>
                <div class="actions">
                    <button class="btn-secondary" onclick="undoDraw()">‚Ü©Ô∏è Undo</button>
                    <button class="btn-primary" onclick="saveDrawing()">üíæ Save</button>
                    <button class="btn-secondary" onclick="window.print()">üñ®Ô∏è Print</button>
                    <button class="btn-danger" onclick="clearDrawing()">üóëÔ∏è Clear</button>
                </div>
            </div>
        </div>

        <!-- Bottom Ad -->
        <div class="ad-container">
            <ins class="adsbygoogle" style="display:block" data-ad-format="auto"
                data-full-width-responsive="true" data-ad-client="ca-pub-1157507558678597"
                data-ad-slot="XXXXXXXXXX"></ins>
        </div>
    </div>

    <footer class="footer">
        Address Sketch Tool - Generate route maps for bank forms & documents
    </footer>

    <!-- Text Modal -->
    <div class="modal-overlay" id="textModal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.5);justify-content:center;align-items:center;z-index:100;">
        <div style="background:white;padding:20px;border-radius:12px;width:90%;max-width:300px;">
            <h3 style="margin-bottom:12px;font-size:16px;">Add Label</h3>
            <input type="text" id="textInput" placeholder="Enter text..." maxlength="30" style="width:100%;padding:12px;border:2px solid #e0e0e0;border-radius:8px;font-size:15px;margin-bottom:12px;">
            <div style="display:flex;gap:10px;">
                <button onclick="closeTextModal()" style="flex:1;padding:10px;border:none;background:#e0e0e0;border-radius:8px;cursor:pointer;">Cancel</button>
                <button onclick="addText()" style="flex:1;padding:10px;border:none;background:#4a90d9;color:white;border-radius:8px;cursor:pointer;">Add</button>
            </div>
        </div>
    </div>

    <!-- Map Picker Modal -->
    <div id="mapPickerModal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.8);z-index:200;">
        <div style="height:100%;display:flex;flex-direction:column;">
            <div style="background:#4a90d9;color:white;padding:15px;display:flex;justify-content:space-between;align-items:center;">
                <h3 style="font-size:16px;" id="mapPickerTitle">Select Location on Map</h3>
                <button onclick="closeMapPicker()" style="background:none;border:none;color:white;font-size:24px;cursor:pointer;">√ó</button>
            </div>
            <div style="padding:10px;background:#fff;">
                <input type="text" id="mapSearchInput" placeholder="Search location..." style="width:100%;padding:12px;border:2px solid #e0e0e0;border-radius:8px;font-size:15px;">
            </div>
            <div id="pickerMap" style="flex:1;"></div>
            <div style="background:#fff;padding:15px;">
                <div id="selectedLocationText" style="font-size:13px;color:#666;margin-bottom:10px;min-height:20px;">Tap on map to select location</div>
                <div style="display:flex;gap:10px;">
                    <button onclick="closeMapPicker()" style="flex:1;padding:12px;border:none;background:#e0e0e0;border-radius:8px;cursor:pointer;font-size:14px;">Cancel</button>
                    <button onclick="confirmMapSelection()" id="confirmMapBtn" style="flex:1;padding:12px;border:none;background:#27ae60;color:white;border-radius:8px;cursor:pointer;font-size:14px;" disabled>Confirm Location</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ==================== TAB SWITCHING ====================
        function switchTab(tab) {
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));

            if (tab === 'auto') {
                document.querySelector('.tab-btn:nth-child(1)').classList.add('active');
                document.getElementById('autoTab').classList.add('active');
            } else {
                document.querySelector('.tab-btn:nth-child(2)').classList.add('active');
                document.getElementById('manualTab').classList.add('active');
                initDrawCanvas();
            }
        }

        // ==================== AUTO ROUTE GENERATOR ====================
        let map = null;
        let routeData = null;
        let landmarks = [];
        let currentLocationCoords = null;
        let directionsService = null;
        let directionsRenderer = null;

        // Map Picker variables
        let pickerMap = null;
        let pickerMarker = null;
        let pickerTarget = null; // 'from' or 'to'
        let selectedPickerCoords = null;
        let selectedPickerAddress = null;
        let placesAutocomplete = null;

        // Get current location on page load
        window.addEventListener('load', () => {
            getCurrentLocation();
        });

        // ==================== MAP PICKER (Google Maps) ====================
        function openMapPicker(target) {
            pickerTarget = target;
            selectedPickerCoords = null;
            selectedPickerAddress = null;

            const modal = document.getElementById('mapPickerModal');
            const title = document.getElementById('mapPickerTitle');
            const confirmBtn = document.getElementById('confirmMapBtn');
            const selectedText = document.getElementById('selectedLocationText');

            title.textContent = target === 'from' ? 'Select FROM Location' : 'Select TO Location';
            selectedText.textContent = 'Tap on map to select location';
            confirmBtn.disabled = true;
            modal.style.display = 'block';

            // Initialize or reset picker map
            setTimeout(() => {
                if (!pickerMap) {
                    const mapOptions = {
                        center: { lat: 20.5937, lng: 78.9629 }, // India center
                        zoom: 5,
                        mapTypeControl: true,
                        mapTypeControlOptions: {
                            style: google.maps.MapTypeControlStyle.HORIZONTAL_BAR,
                            position: google.maps.ControlPosition.TOP_LEFT,
                            mapTypeIds: ['roadmap', 'satellite', 'hybrid', 'terrain']
                        },
                        streetViewControl: false,
                        fullscreenControl: false
                    };
                    pickerMap = new google.maps.Map(document.getElementById('pickerMap'), mapOptions);

                    // Click to select location
                    pickerMap.addListener('click', (e) => {
                        selectLocationOnMap(e.latLng.lat(), e.latLng.lng());
                    });

                    // Setup Places Autocomplete
                    const searchInput = document.getElementById('mapSearchInput');
                    placesAutocomplete = new google.maps.places.Autocomplete(searchInput, {
                        fields: ['geometry', 'formatted_address', 'name']
                    });
                    placesAutocomplete.addListener('place_changed', () => {
                        const place = placesAutocomplete.getPlace();
                        if (place.geometry) {
                            const lat = place.geometry.location.lat();
                            const lng = place.geometry.location.lng();
                            pickerMap.setCenter({ lat, lng });
                            pickerMap.setZoom(16);
                            selectLocationOnMap(lat, lng, place.formatted_address || place.name);
                        }
                    });
                }

                // If we have current location, center there
                if (currentLocationCoords && target === 'from') {
                    pickerMap.setCenter({ lat: currentLocationCoords.lat, lng: currentLocationCoords.lng });
                    pickerMap.setZoom(15);
                } else if (currentLocationCoords) {
                    pickerMap.setCenter({ lat: currentLocationCoords.lat, lng: currentLocationCoords.lng });
                    pickerMap.setZoom(13);
                }

                // Remove existing marker
                if (pickerMarker) {
                    pickerMarker.setMap(null);
                    pickerMarker = null;
                }

                // Clear search input
                document.getElementById('mapSearchInput').value = '';
            }, 100);
        }

        async function selectLocationOnMap(lat, lng, address = null) {
            selectedPickerCoords = { lat, lng };

            // Update marker
            if (pickerMarker) {
                pickerMarker.setMap(null);
            }
            pickerMarker = new google.maps.Marker({
                position: { lat, lng },
                map: pickerMap,
                animation: google.maps.Animation.DROP
            });

            // Reverse geocode
            const selectedText = document.getElementById('selectedLocationText');
            const confirmBtn = document.getElementById('confirmMapBtn');

            if (address) {
                selectedPickerAddress = address;
                selectedText.textContent = address;
                confirmBtn.disabled = false;
                return;
            }

            selectedText.textContent = 'Getting address...';

            const geocoder = new google.maps.Geocoder();
            geocoder.geocode({ location: { lat, lng } }, (results, status) => {
                if (status === 'OK' && results[0]) {
                    selectedPickerAddress = results[0].formatted_address;
                    selectedText.textContent = selectedPickerAddress;
                } else {
                    selectedPickerAddress = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
                    selectedText.textContent = selectedPickerAddress;
                }
                confirmBtn.disabled = false;
            });
        }

        function confirmMapSelection() {
            if (!selectedPickerCoords || !selectedPickerAddress) return;

            if (pickerTarget === 'from') {
                document.getElementById('fromLocation').value = selectedPickerAddress;
                document.getElementById('locationHint').textContent = '‚úì Location selected from map';
                document.getElementById('locationHint').style.color = '#27ae60';
                currentLocationCoords = selectedPickerCoords;
            } else {
                document.getElementById('toLocation').value = selectedPickerAddress;
                document.getElementById('toHint').textContent = '‚úì Location selected from map';
                document.getElementById('toHint').style.color = '#27ae60';
            }

            closeMapPicker();
        }

        function closeMapPicker() {
            document.getElementById('mapPickerModal').style.display = 'none';
        }

        async function getCurrentLocation() {
            const btn = document.getElementById('getLocationBtn');
            const input = document.getElementById('fromLocation');
            const hint = document.getElementById('locationHint');

            if (!navigator.geolocation) {
                hint.textContent = 'Geolocation not supported. Enter address manually.';
                hint.style.color = '#e74c3c';
                return;
            }

            btn.disabled = true;
            btn.textContent = 'üìç Locating...';
            hint.textContent = 'Getting your location...';

            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;
                    currentLocationCoords = { lat, lng };

                    // Reverse geocode using Google
                    const geocoder = new google.maps.Geocoder();
                    geocoder.geocode({ location: { lat, lng } }, (results, status) => {
                        if (status === 'OK' && results[0]) {
                            input.value = results[0].formatted_address;
                            hint.textContent = '‚úì Location detected! You can edit if needed.';
                            hint.style.color = '#27ae60';
                        } else {
                            input.value = `${lat.toFixed(6)}, ${lng.toFixed(6)}`;
                            hint.textContent = '‚úì Coordinates detected';
                            hint.style.color = '#27ae60';
                        }
                        btn.disabled = false;
                        btn.textContent = 'üìç My Location';
                    });
                },
                (error) => {
                    btn.disabled = false;
                    btn.textContent = 'üìç Try Again';
                    hint.style.color = '#e74c3c';

                    switch (error.code) {
                        case error.PERMISSION_DENIED:
                            hint.textContent = 'Location access denied. Enter address manually.';
                            break;
                        case error.POSITION_UNAVAILABLE:
                            hint.textContent = 'Location unavailable. Enter address manually.';
                            break;
                        case error.TIMEOUT:
                            hint.textContent = 'Location timeout. Try again or enter manually.';
                            break;
                        default:
                            hint.textContent = 'Could not get location. Enter address manually.';
                    }
                },
                { enableHighAccuracy: true, timeout: 10000, maximumAge: 60000 }
            );
        }

        async function generateRoute() {
            const from = document.getElementById('fromLocation').value.trim();
            const to = document.getElementById('toLocation').value.trim();
            const statusMsg = document.getElementById('statusMsg');
            const generateBtn = document.getElementById('generateBtn');

            if (!from || !to) {
                statusMsg.textContent = 'Please enter both FROM and TO locations';
                statusMsg.className = 'status-msg error';
                return;
            }

            generateBtn.disabled = true;
            generateBtn.innerHTML = '<span class="loading"><span class="spinner"></span> Generating...</span>';
            statusMsg.textContent = '';

            try {
                // Step 1: Geocode both locations
                statusMsg.textContent = 'Finding locations...';
                const [fromCoords, toCoords] = await Promise.all([
                    geocode(from),
                    geocode(to)
                ]);

                if (!fromCoords || !toCoords) {
                    throw new Error('Could not find one or both locations. Try more specific addresses.');
                }

                // Step 2: Get route
                statusMsg.textContent = 'Calculating route...';
                const route = await getRoute(fromCoords, toCoords);

                if (!route) {
                    throw new Error('Could not find a route between these locations.');
                }

                // Step 3: Get landmarks and rivers along route
                statusMsg.textContent = 'Finding landmarks and rivers...';
                const poiData = await getLandmarks(route.bbox, route.coordinates);
                landmarks = poiData.landmarks;
                const rivers = poiData.rivers;

                // Step 4: Show map
                showMap(fromCoords, toCoords, route);

                // Step 5: Generate simplified sketch
                statusMsg.textContent = 'Drawing sketch...';
                await generateSketch(fromCoords, toCoords, route, landmarks, rivers, from, to);

                statusMsg.textContent = 'Route generated! Scroll down to see the sketch.';
                statusMsg.className = 'status-msg';

            } catch (error) {
                statusMsg.textContent = error.message;
                statusMsg.className = 'status-msg error';
            } finally {
                generateBtn.disabled = false;
                generateBtn.innerHTML = 'Generate Route Sketch';
            }
        }

        async function geocode(address) {
            return new Promise((resolve) => {
                const geocoder = new google.maps.Geocoder();
                geocoder.geocode({ address: address }, (results, status) => {
                    if (status === 'OK' && results[0]) {
                        resolve({
                            lat: results[0].geometry.location.lat(),
                            lng: results[0].geometry.location.lng(),
                            name: results[0].formatted_address
                        });
                    } else {
                        resolve(null);
                    }
                });
            });
        }

        async function getRoute(from, to) {
            return new Promise((resolve) => {
                if (!directionsService) {
                    directionsService = new google.maps.DirectionsService();
                }

                directionsService.route({
                    origin: { lat: from.lat, lng: from.lng },
                    destination: { lat: to.lat, lng: to.lng },
                    travelMode: google.maps.TravelMode.DRIVING
                }, (result, status) => {
                    if (status === 'OK' && result.routes && result.routes.length > 0) {
                        const route = result.routes[0];
                        const leg = route.legs[0];
                        const path = route.overview_path;

                        // Extract coordinates
                        const coords = path.map(p => ({ lat: p.lat(), lng: p.lng() }));

                        // Calculate bounding box
                        let minLat = Infinity, maxLat = -Infinity;
                        let minLng = Infinity, maxLng = -Infinity;

                        coords.forEach(c => {
                            minLng = Math.min(minLng, c.lng);
                            maxLng = Math.max(maxLng, c.lng);
                            minLat = Math.min(minLat, c.lat);
                            maxLat = Math.max(maxLat, c.lat);
                        });

                        resolve({
                            coordinates: coords,
                            steps: leg.steps,
                            distance: leg.distance.value,
                            duration: leg.duration.value,
                            bbox: { minLat, maxLat, minLng, maxLng },
                            googleRoute: result
                        });
                    } else {
                        resolve(null);
                    }
                });
            });
        }

        async function getLandmarks(bbox, routeCoords) {
            // Larger padding for better landmark coverage
            const padding = 0.01;
            const b = {
                minLat: bbox.minLat - padding,
                maxLat: bbox.maxLat + padding,
                minLng: bbox.minLng - padding,
                maxLng: bbox.maxLng + padding
            };

            const query = `
                [out:json][timeout:30];
                (
                    // Landmarks
                    node["amenity"~"hospital|bank|fuel|school|place_of_worship|police|bus_station|marketplace"](${b.minLat},${b.minLng},${b.maxLat},${b.maxLng});
                    node["shop"~"supermarket|mall|department_store"](${b.minLat},${b.minLng},${b.maxLat},${b.maxLng});
                    node["railway"="station"](${b.minLat},${b.minLng},${b.maxLat},${b.maxLng});
                    node["highway"~"traffic_signals|bus_stop"](${b.minLat},${b.minLng},${b.maxLat},${b.maxLng});
                    node["tourism"~"hotel|viewpoint"](${b.minLat},${b.minLng},${b.maxLat},${b.maxLng});
                    node["natural"="peak"](${b.minLat},${b.minLng},${b.maxLat},${b.maxLng});
                    // Rivers and water
                    way["waterway"~"river|stream"](${b.minLat},${b.minLng},${b.maxLat},${b.maxLng});
                    way["natural"="water"](${b.minLat},${b.minLng},${b.maxLat},${b.maxLng});
                );
                out body geom 50;
            `;

            try {
                const response = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    body: query
                });
                const data = await response.json();

                const landmarks = [];
                const rivers = [];

                data.elements.forEach(el => {
                    if (el.type === 'way' && (el.tags.waterway || el.tags.natural === 'water')) {
                        // It's a river/water body
                        if (el.geometry) {
                            rivers.push({
                                type: 'river',
                                name: el.tags.name || '',
                                coords: el.geometry.map(g => ({ lat: g.lat, lng: g.lon }))
                            });
                        }
                    } else if (el.type === 'node') {
                        // It's a landmark
                        landmarks.push({
                            lat: el.lat,
                            lng: el.lon,
                            type: el.tags.amenity || el.tags.shop || el.tags.railway || el.tags.highway || el.tags.tourism || el.tags.natural,
                            name: el.tags.name || ''
                        });
                    }
                });

                // Filter landmarks to those near the route
                const nearbyLandmarks = landmarks.filter(lm => {
                    return isNearRoute(lm, routeCoords, 0.008); // ~800m from route
                }).slice(0, 15);

                return { landmarks: nearbyLandmarks, rivers };
            } catch (e) {
                console.error('Landmark fetch error:', e);
                return { landmarks: [], rivers: [] };
            }
        }

        function isNearRoute(point, routeCoords, threshold) {
            for (let i = 0; i < routeCoords.length; i++) {
                const dist = Math.sqrt(
                    Math.pow(point.lat - routeCoords[i].lat, 2) +
                    Math.pow(point.lng - routeCoords[i].lng, 2)
                );
                if (dist < threshold) return true;
            }
            return false;
        }

        function showMap(from, to, route) {
            const mapContainer = document.getElementById('mapContainer');
            mapContainer.style.display = 'block';

            if (!map) {
                map = new google.maps.Map(document.getElementById('map'), {
                    center: { lat: from.lat, lng: from.lng },
                    zoom: 12,
                    mapTypeControl: true,
                    mapTypeControlOptions: {
                        style: google.maps.MapTypeControlStyle.HORIZONTAL_BAR,
                        position: google.maps.ControlPosition.TOP_RIGHT,
                        mapTypeIds: ['roadmap', 'satellite', 'hybrid', 'terrain']
                    },
                    streetViewControl: false
                });
                directionsRenderer = new google.maps.DirectionsRenderer({
                    suppressMarkers: false,
                    polylineOptions: {
                        strokeColor: '#4a90d9',
                        strokeWeight: 5
                    }
                });
                directionsRenderer.setMap(map);
            }

            // Display route using Google Directions
            if (route.googleRoute) {
                directionsRenderer.setDirections(route.googleRoute);
            }
        }

        // ==================== ANIMATED ROUTE VISUALIZATION ====================
        let routeCanvas, routeCtx;
        let currentZoom = 1;
        let animationId = null;
        let routeRenderData = null;

        async function generateSketch(from, to, route, landmarks, rivers, fromLabel, toLabel) {
            const container = document.getElementById('routeDisplay');
            container.style.display = 'block';

            // Update header
            document.getElementById('routeTitle').textContent = 'Your Route';
            document.getElementById('routeDistanceLabel').textContent = `${(route.distance / 1000).toFixed(1)} km`;

            routeCanvas = document.getElementById('routeCanvas');
            routeCtx = routeCanvas.getContext('2d');

            const padding = 80;
            const width = routeCanvas.width - padding * 2;
            const height = routeCanvas.height - padding * 2;

            // Calculate bounds
            const bbox = { ...route.bbox };
            const scaleX = width / (bbox.maxLng - bbox.minLng || 0.001);
            const scaleY = height / (bbox.maxLat - bbox.minLat || 0.001);
            const baseScale = Math.min(scaleX, scaleY) * 0.9;

            const centerLng = (bbox.minLng + bbox.maxLng) / 2;
            const centerLat = (bbox.minLat + bbox.maxLat) / 2;

            // Store for later use
            routeRenderData = {
                from, to, route, landmarks, rivers, fromLabel, toLabel,
                padding, width, height, baseScale, centerLng, centerLat, bbox
            };

            // Display turn instructions
            displayTurnInstructions(route.steps);

            // Start animation
            currentZoom = 1;
            animateRoute();

            container.scrollIntoView({ behavior: 'smooth' });
        }

        function toCanvasCoord(lat, lng) {
            const d = routeRenderData;
            const scale = d.baseScale * currentZoom;
            return {
                x: d.padding + d.width / 2 + (lng - d.centerLng) * scale,
                y: d.padding + d.height / 2 - (lat - d.centerLat) * scale
            };
        }

        function animateRoute() {
            if (animationId) cancelAnimationFrame(animationId);

            const d = routeRenderData;
            const coords = d.route.coordinates;
            let currentIndex = 0;
            const speed = Math.max(1, Math.floor(coords.length / 120)); // Adjust speed based on route length

            function draw() {
                // Clear canvas with dark background
                routeCtx.fillStyle = '#0f172a';
                routeCtx.fillRect(0, 0, routeCanvas.width, routeCanvas.height);

                // Draw grid pattern
                drawGrid();

                // Draw rivers
                drawRivers(d.rivers);

                // Draw fading side roads at turns
                drawSideRoads(coords, currentIndex);

                // Draw main road (traveled portion with glow)
                drawMainRoad(coords, currentIndex);

                // Draw landmarks
                drawLandmarks(d.landmarks);

                // Draw start marker
                const startP = toCanvasCoord(d.from.lat, d.from.lng);
                drawMarker(startP.x, startP.y, 'üìç', 'START', '#ef4444');

                // Draw end marker
                const endP = toCanvasCoord(d.to.lat, d.to.lng);
                drawMarker(endP.x, endP.y, 'üè†', 'HOME', '#22c55e');

                // Draw animated car/dot on current position
                if (currentIndex < coords.length) {
                    const pos = toCanvasCoord(coords[currentIndex].lat, coords[currentIndex].lng);
                    drawAnimatedDot(pos.x, pos.y);
                }

                // Draw compass
                drawCompass();

                // Continue animation
                if (currentIndex < coords.length - 1) {
                    currentIndex += speed;
                    if (currentIndex >= coords.length) currentIndex = coords.length - 1;
                    animationId = requestAnimationFrame(draw);
                } else {
                    // Animation complete - draw final state
                    drawFinalRoute();
                }
            }

            draw();
        }

        function drawGrid() {
            routeCtx.strokeStyle = 'rgba(255,255,255,0.03)';
            routeCtx.lineWidth = 1;
            const gridSize = 40;
            for (let x = 0; x < routeCanvas.width; x += gridSize) {
                routeCtx.beginPath();
                routeCtx.moveTo(x, 0);
                routeCtx.lineTo(x, routeCanvas.height);
                routeCtx.stroke();
            }
            for (let y = 0; y < routeCanvas.height; y += gridSize) {
                routeCtx.beginPath();
                routeCtx.moveTo(0, y);
                routeCtx.lineTo(routeCanvas.width, y);
                routeCtx.stroke();
            }
        }

        function drawRivers(rivers) {
            if (!rivers || rivers.length === 0) return;

            routeCtx.strokeStyle = '#0ea5e9';
            routeCtx.lineWidth = 4;
            routeCtx.lineCap = 'round';
            routeCtx.lineJoin = 'round';
            routeCtx.shadowColor = '#0ea5e9';
            routeCtx.shadowBlur = 8;

            rivers.forEach(river => {
                if (river.coords && river.coords.length > 1) {
                    routeCtx.beginPath();
                    river.coords.forEach((coord, i) => {
                        const p = toCanvasCoord(coord.lat, coord.lng);
                        if (i === 0) routeCtx.moveTo(p.x, p.y);
                        else routeCtx.lineTo(p.x, p.y);
                    });
                    routeCtx.stroke();

                    // River name
                    if (river.name) {
                        const midIdx = Math.floor(river.coords.length / 2);
                        const midP = toCanvasCoord(river.coords[midIdx].lat, river.coords[midIdx].lng);
                        routeCtx.shadowBlur = 0;
                        routeCtx.font = 'italic 11px Arial';
                        routeCtx.fillStyle = '#38bdf8';
                        routeCtx.fillText(river.name, midP.x + 5, midP.y - 8);
                    }
                }
            });
            routeCtx.shadowBlur = 0;
        }

        function drawSideRoads(coords, upToIndex) {
            // Find turns and draw fading alternate roads
            for (let i = 1; i < Math.min(upToIndex, coords.length - 1); i++) {
                const prev = coords[i - 1];
                const curr = coords[i];
                const next = coords[i + 1];

                const angle1 = Math.atan2(curr.lat - prev.lat, curr.lng - prev.lng);
                const angle2 = Math.atan2(next.lat - curr.lat, next.lng - curr.lng);
                let diff = Math.abs(angle1 - angle2);
                if (diff > Math.PI) diff = 2 * Math.PI - diff;

                // If it's a significant turn, draw fading alternate road
                if (diff > 0.5) {
                    const p = toCanvasCoord(curr.lat, curr.lng);

                    // Draw fading road in the direction not taken
                    const notTakenAngle = angle1; // Continue straight
                    const fadeLength = 50;

                    const gradient = routeCtx.createLinearGradient(
                        p.x, p.y,
                        p.x + Math.cos(notTakenAngle) * fadeLength,
                        p.y - Math.sin(notTakenAngle) * fadeLength
                    );
                    gradient.addColorStop(0, 'rgba(100,100,100,0.6)');
                    gradient.addColorStop(1, 'rgba(100,100,100,0)');

                    routeCtx.strokeStyle = gradient;
                    routeCtx.lineWidth = 12;
                    routeCtx.lineCap = 'round';
                    routeCtx.beginPath();
                    routeCtx.moveTo(p.x, p.y);
                    routeCtx.lineTo(
                        p.x + Math.cos(notTakenAngle) * fadeLength,
                        p.y - Math.sin(notTakenAngle) * fadeLength
                    );
                    routeCtx.stroke();
                }
            }
        }

        function drawMainRoad(coords, upToIndex) {
            if (coords.length < 2) return;

            const endIdx = Math.min(upToIndex + 1, coords.length);

            // Draw road shadow
            routeCtx.strokeStyle = 'rgba(0,0,0,0.3)';
            routeCtx.lineWidth = 18;
            routeCtx.lineCap = 'round';
            routeCtx.lineJoin = 'round';
            routeCtx.beginPath();
            for (let i = 0; i < endIdx; i++) {
                const p = toCanvasCoord(coords[i].lat, coords[i].lng);
                if (i === 0) routeCtx.moveTo(p.x + 2, p.y + 2);
                else routeCtx.lineTo(p.x + 2, p.y + 2);
            }
            routeCtx.stroke();

            // Draw road base (dark gray)
            routeCtx.strokeStyle = '#374151';
            routeCtx.lineWidth = 16;
            routeCtx.beginPath();
            for (let i = 0; i < endIdx; i++) {
                const p = toCanvasCoord(coords[i].lat, coords[i].lng);
                if (i === 0) routeCtx.moveTo(p.x, p.y);
                else routeCtx.lineTo(p.x, p.y);
            }
            routeCtx.stroke();

            // Draw road surface (lighter)
            routeCtx.strokeStyle = '#4b5563';
            routeCtx.lineWidth = 12;
            routeCtx.beginPath();
            for (let i = 0; i < endIdx; i++) {
                const p = toCanvasCoord(coords[i].lat, coords[i].lng);
                if (i === 0) routeCtx.moveTo(p.x, p.y);
                else routeCtx.lineTo(p.x, p.y);
            }
            routeCtx.stroke();

            // Draw center line (dashed yellow)
            routeCtx.strokeStyle = '#fbbf24';
            routeCtx.lineWidth = 2;
            routeCtx.setLineDash([10, 15]);
            routeCtx.beginPath();
            for (let i = 0; i < endIdx; i++) {
                const p = toCanvasCoord(coords[i].lat, coords[i].lng);
                if (i === 0) routeCtx.moveTo(p.x, p.y);
                else routeCtx.lineTo(p.x, p.y);
            }
            routeCtx.stroke();
            routeCtx.setLineDash([]);

            // Draw glowing route line on top
            routeCtx.strokeStyle = '#4ade80';
            routeCtx.lineWidth = 4;
            routeCtx.shadowColor = '#4ade80';
            routeCtx.shadowBlur = 10;
            routeCtx.beginPath();
            for (let i = 0; i < endIdx; i++) {
                const p = toCanvasCoord(coords[i].lat, coords[i].lng);
                if (i === 0) routeCtx.moveTo(p.x, p.y);
                else routeCtx.lineTo(p.x, p.y);
            }
            routeCtx.stroke();
            routeCtx.shadowBlur = 0;
        }

        function drawLandmarks(landmarks) {
            if (!landmarks) return;

            const icons = {
                'hospital': 'üè•', 'bank': 'üè¶', 'fuel': '‚õΩ', 'school': 'üè´',
                'place_of_worship': '‚õ™', 'police': 'üöî', 'supermarket': 'üè™',
                'mall': 'üè¨', 'station': 'üöâ', 'traffic_signals': 'üö¶',
                'bus_stop': 'üöè', 'bus_station': 'üöå', 'hotel': 'üè®', 'peak': '‚õ∞Ô∏è'
            };

            landmarks.forEach(lm => {
                const p = toCanvasCoord(lm.lat, lm.lng);
                const icon = icons[lm.type] || '‚≠ê';

                // Draw background circle
                routeCtx.fillStyle = 'rgba(0,0,0,0.5)';
                routeCtx.beginPath();
                routeCtx.arc(p.x, p.y, 18, 0, Math.PI * 2);
                routeCtx.fill();

                // Draw icon
                routeCtx.font = '20px Arial';
                routeCtx.fillText(icon, p.x - 10, p.y + 7);

                // Draw name
                if (lm.name) {
                    routeCtx.font = '10px Arial';
                    routeCtx.fillStyle = '#94a3b8';
                    const shortName = lm.name.length > 15 ? lm.name.substring(0, 15) + '..' : lm.name;
                    routeCtx.fillText(shortName, p.x - 20, p.y + 30);
                }
            });
        }

        function drawMarker(x, y, icon, label, color) {
            // Glow
            routeCtx.shadowColor = color;
            routeCtx.shadowBlur = 20;
            routeCtx.fillStyle = color;
            routeCtx.beginPath();
            routeCtx.arc(x, y, 8, 0, Math.PI * 2);
            routeCtx.fill();
            routeCtx.shadowBlur = 0;

            // Icon
            routeCtx.font = '28px Arial';
            routeCtx.fillText(icon, x - 14, y - 15);

            // Label
            routeCtx.font = 'bold 12px Arial';
            routeCtx.fillStyle = color;
            routeCtx.fillText(label, x - 18, y + 28);
        }

        function drawAnimatedDot(x, y) {
            const time = Date.now() / 200;
            const pulse = Math.sin(time) * 3 + 8;

            routeCtx.shadowColor = '#4ade80';
            routeCtx.shadowBlur = 15;
            routeCtx.fillStyle = '#4ade80';
            routeCtx.beginPath();
            routeCtx.arc(x, y, pulse, 0, Math.PI * 2);
            routeCtx.fill();

            routeCtx.fillStyle = '#fff';
            routeCtx.beginPath();
            routeCtx.arc(x, y, 4, 0, Math.PI * 2);
            routeCtx.fill();
            routeCtx.shadowBlur = 0;
        }

        function drawCompass() {
            const x = routeCanvas.width - 40;
            const y = 50;

            routeCtx.fillStyle = 'rgba(255,255,255,0.1)';
            routeCtx.beginPath();
            routeCtx.arc(x, y, 20, 0, Math.PI * 2);
            routeCtx.fill();

            routeCtx.fillStyle = '#ef4444';
            routeCtx.font = 'bold 14px Arial';
            routeCtx.fillText('N', x - 5, y - 5);

            routeCtx.strokeStyle = '#ef4444';
            routeCtx.lineWidth = 2;
            routeCtx.beginPath();
            routeCtx.moveTo(x, y);
            routeCtx.lineTo(x, y - 15);
            routeCtx.stroke();
        }

        function drawFinalRoute() {
            const d = routeRenderData;

            // Clear and redraw everything
            routeCtx.fillStyle = '#0f172a';
            routeCtx.fillRect(0, 0, routeCanvas.width, routeCanvas.height);

            drawGrid();
            drawRivers(d.rivers);
            drawSideRoads(d.route.coordinates, d.route.coordinates.length);
            drawMainRoad(d.route.coordinates, d.route.coordinates.length);
            drawLandmarks(d.landmarks);

            const startP = toCanvasCoord(d.from.lat, d.from.lng);
            drawMarker(startP.x, startP.y, 'üìç', 'START', '#ef4444');

            const endP = toCanvasCoord(d.to.lat, d.to.lng);
            drawMarker(endP.x, endP.y, 'üè†', 'HOME', '#22c55e');

            drawCompass();

            // Update info
            document.getElementById('routeInfo').innerHTML = `
                <strong>${d.fromLabel.substring(0, 30)}${d.fromLabel.length > 30 ? '...' : ''}</strong><br>
                ‚Üí ${d.toLabel.substring(0, 30)}${d.toLabel.length > 30 ? '...' : ''}
            `;
        }

        function displayTurnInstructions(steps) {
            const container = document.getElementById('turnInstructions');
            if (!steps || steps.length === 0) {
                container.innerHTML = '<div style="color:#64748b;text-align:center;">No turn-by-turn directions available</div>';
                return;
            }

            const turnIcons = {
                'turn-left': '‚Ü∞', 'turn-right': '‚Ü±', 'straight': '‚Üë',
                'merge': '‚§®', 'roundabout': '‚Üª', 'uturn': '‚Ü©'
            };

            let html = '';
            steps.slice(0, 8).forEach((step, i) => {
                const instruction = step.instructions ? step.instructions.replace(/<[^>]*>/g, '') : 'Continue';
                const dist = step.distance ? step.distance.text : '';
                let icon = '‚Üí';

                if (instruction.toLowerCase().includes('left')) icon = '‚Ü∞';
                else if (instruction.toLowerCase().includes('right')) icon = '‚Ü±';
                else if (instruction.toLowerCase().includes('straight') || instruction.toLowerCase().includes('continue')) icon = '‚Üë';

                html += `
                    <div class="turn-item">
                        <div class="turn-icon">${icon}</div>
                        <div style="flex:1;">${instruction}</div>
                        <div style="color:#64748b;font-size:11px;">${dist}</div>
                    </div>
                `;
            });

            if (steps.length > 8) {
                html += `<div style="text-align:center;color:#64748b;padding:8px;">+ ${steps.length - 8} more steps</div>`;
            }

            container.innerHTML = html;
        }

        function zoomRoute(factor) {
            currentZoom *= factor;
            currentZoom = Math.max(0.5, Math.min(3, currentZoom));
            if (routeRenderData) drawFinalRoute();
        }

        function resetZoom() {
            currentZoom = 1;
            if (routeRenderData) drawFinalRoute();
        }

        function replayAnimation() {
            if (routeRenderData) animateRoute();
        }

        function saveRoute() {
            const link = document.createElement('a');
            link.download = 'route-map.png';
            link.href = routeCanvas.toDataURL('image/png');
            link.click();
        }

        // ==================== MANUAL DRAWING ====================
        let drawCanvas, drawCtx;
        let currentTool = 'pen';
        let currentColor = '#000';
        let currentSize = 2;
        let isDrawing = false;
        let lastX = 0, lastY = 0;
        let lineStartX = 0, lineStartY = 0;
        let drawHistory = [];
        let pendingLandmark = null;
        let textPosition = null;

        function initDrawCanvas() {
            if (drawCanvas) return;

            drawCanvas = document.getElementById('drawCanvas');
            drawCtx = drawCanvas.getContext('2d');

            drawCtx.fillStyle = '#fff';
            drawCtx.fillRect(0, 0, drawCanvas.width, drawCanvas.height);
            saveDrawState();

            document.querySelectorAll('#manualTab .tool-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#manualTab .tool-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentTool = btn.dataset.tool;
                    pendingLandmark = null;
                });
            });

            document.querySelectorAll('#manualTab .color-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#manualTab .color-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentColor = btn.dataset.color;
                });
            });

            document.getElementById('sizeSlider').addEventListener('input', e => {
                currentSize = parseInt(e.target.value);
            });

            document.querySelectorAll('#manualTab .landmark-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    pendingLandmark = btn.dataset.emoji;
                });
            });

            drawCanvas.addEventListener('mousedown', startDraw);
            drawCanvas.addEventListener('mousemove', draw);
            drawCanvas.addEventListener('mouseup', endDraw);
            drawCanvas.addEventListener('mouseleave', endDraw);
            drawCanvas.addEventListener('touchstart', e => { e.preventDefault(); startDraw(e); }, { passive: false });
            drawCanvas.addEventListener('touchmove', e => { e.preventDefault(); draw(e); }, { passive: false });
            drawCanvas.addEventListener('touchend', e => { e.preventDefault(); endDraw(e); }, { passive: false });
        }

        function getDrawPos(e) {
            const rect = drawCanvas.getBoundingClientRect();
            const scaleX = drawCanvas.width / rect.width;
            const scaleY = drawCanvas.height / rect.height;
            let clientX, clientY;
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        function startDraw(e) {
            const pos = getDrawPos(e);
            if (pendingLandmark) {
                drawCtx.font = '28px Arial';
                drawCtx.fillText(pendingLandmark, pos.x - 14, pos.y + 10);
                pendingLandmark = null;
                saveDrawState();
                return;
            }
            if (currentTool === 'text') {
                textPosition = pos;
                document.getElementById('textModal').style.display = 'flex';
                document.getElementById('textInput').value = '';
                document.getElementById('textInput').focus();
                return;
            }
            isDrawing = true;
            lastX = pos.x;
            lastY = pos.y;
            lineStartX = pos.x;
            lineStartY = pos.y;
        }

        function draw(e) {
            if (!isDrawing) return;
            const pos = getDrawPos(e);
            if (currentTool === 'pen' || currentTool === 'eraser') {
                drawCtx.strokeStyle = currentTool === 'eraser' ? '#fff' : currentColor;
                drawCtx.lineWidth = currentTool === 'eraser' ? currentSize * 4 : currentSize;
                drawCtx.lineCap = 'round';
                drawCtx.beginPath();
                drawCtx.moveTo(lastX, lastY);
                drawCtx.lineTo(pos.x, pos.y);
                drawCtx.stroke();
                lastX = pos.x;
                lastY = pos.y;
            }
        }

        function endDraw(e) {
            if (!isDrawing) return;
            if (currentTool === 'line') {
                const pos = getDrawPos(e);
                drawCtx.strokeStyle = currentColor;
                drawCtx.lineWidth = currentSize;
                drawCtx.lineCap = 'round';
                drawCtx.beginPath();
                drawCtx.moveTo(lineStartX, lineStartY);
                drawCtx.lineTo(pos.x, pos.y);
                drawCtx.stroke();
            }
            isDrawing = false;
            saveDrawState();
        }

        function saveDrawState() {
            drawHistory.push(drawCanvas.toDataURL());
            if (drawHistory.length > 30) drawHistory.shift();
        }

        function undoDraw() {
            if (drawHistory.length > 1) {
                drawHistory.pop();
                const img = new Image();
                img.onload = () => {
                    drawCtx.fillStyle = '#fff';
                    drawCtx.fillRect(0, 0, drawCanvas.width, drawCanvas.height);
                    drawCtx.drawImage(img, 0, 0);
                };
                img.src = drawHistory[drawHistory.length - 1];
            }
        }

        function clearDrawing() {
            if (confirm('Clear the entire sketch?')) {
                drawCtx.fillStyle = '#fff';
                drawCtx.fillRect(0, 0, drawCanvas.width, drawCanvas.height);
                saveDrawState();
            }
        }

        function saveDrawing() {
            const link = document.createElement('a');
            link.download = 'address-sketch.png';
            link.href = drawCanvas.toDataURL('image/png');
            link.click();
        }

        function addText() {
            const text = document.getElementById('textInput').value.trim();
            if (text && textPosition) {
                drawCtx.font = `${14 + currentSize}px Arial`;
                drawCtx.fillStyle = currentColor;
                drawCtx.fillText(text, textPosition.x, textPosition.y);
                saveDrawState();
            }
            closeTextModal();
        }

        function closeTextModal() {
            document.getElementById('textModal').style.display = 'none';
            textPosition = null;
        }

        document.getElementById('textInput').addEventListener('keydown', e => {
            if (e.key === 'Enter') addText();
            if (e.key === 'Escape') closeTextModal();
        });

        // Service Worker
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js').catch(() => {});
        }
    </script>
</body>
</html>
